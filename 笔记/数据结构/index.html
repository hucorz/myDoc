
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://hucorz.github.io/myDoc/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
      
      <link rel="icon" href="../../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.3.4">
    
    
      
        <title>数据结构 - hucorz's Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.4a0965b7.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="hucorz&#39;s Docs" class="md-header__button md-logo" aria-label="hucorz's Docs" data-md-component="logo">
      
  <img src="../../img/cat-solid.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            hucorz's Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              数据结构
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hucorz/myDoc" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    hucorz/myDoc
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../OI/%E5%8F%82%E8%80%83/" class="md-tabs__link">
        OI
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="md-tabs__link">
        笔记
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../%E5%89%8D%E7%AB%AF/HTML/" class="md-tabs__link">
        前端
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../Python/%E8%AF%B4%E6%98%8E/" class="md-tabs__link">
        Python
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../ML/%E8%AF%B4%E6%98%8E/" class="md-tabs__link">
        ML
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../%E5%85%B6%E4%BB%96/Mkdocs/" class="md-tabs__link">
        其他
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="hucorz&#39;s Docs" class="md-nav__button md-logo" aria-label="hucorz's Docs" data-md-component="logo">
      
  <img src="../../img/cat-solid.svg" alt="logo">

    </a>
    hucorz's Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hucorz/myDoc" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    hucorz/myDoc
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          OI
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="OI" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          OI
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E5%8F%82%E8%80%83/" class="md-nav__link">
        参考
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E6%95%B0%E8%AE%BA/" class="md-nav__link">
        数论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="md-nav__link">
        计算几何
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E5%9B%BE%E8%AE%BA/" class="md-nav__link">
        图论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="md-nav__link">
        数据结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        字符串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/%E5%85%B6%E4%BB%96/" class="md-nav__link">
        其他
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../OI/STL/" class="md-nav__link">
        STL
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="笔记" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        数据库系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2" type="checkbox" id="__nav_3_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3_2">
          线性代数
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="线性代数" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          线性代数
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../笔记/线性代数/说明.md" class="md-nav__link">
        说明
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../笔记/线性代数/Chapter1.md" class="md-nav__link">
        Chapter1
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          前端
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="前端" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          前端
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%89%8D%E7%AB%AF/HTML/" class="md-nav__link">
        HTML
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          Python
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Python" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Python
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/%E8%AF%B4%E6%98%8E/" class="md-nav__link">
        说明
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/Numpy/" class="md-nav__link">
        Numpy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/Pandas/" class="md-nav__link">
        Pandas
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/Matplotlib/" class="md-nav__link">
        Matplotlib
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/Pymssql/" class="md-nav__link">
        Pymssql
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Python/Streamlit.md" class="md-nav__link">
        Streamlit
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          ML
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="ML" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          ML
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/%E8%AF%B4%E6%98%8E/" class="md-nav__link">
        说明
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/1_Regression/" class="md-nav__link">
        Regression
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/2_Classification/" class="md-nav__link">
        Classification
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/3_Logistic%20Regression/" class="md-nav__link">
        Logistic Regression
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/4_Deep%20learning/" class="md-nav__link">
        Deep Learning
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/5_Convolutional%20Neural%20Network/" class="md-nav__link">
        CNN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/6_Recurrent%20Neural%20Network/" class="md-nav__link">
        RNN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/7_Semi-supervised%20Learning/" class="md-nav__link">
        Semi Supervised Learning
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/8_Unsupervised%20Learning%20Word%20Embedding/" class="md-nav__link">
        Unsupervised Learning:Word Embedding
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/Pytorch/" class="md-nav__link">
        Pytorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../ML/Keras/" class="md-nav__link">
        Keras
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          其他
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="其他" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          其他
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%85%B6%E4%BB%96/Mkdocs/" class="md-nav__link">
        Mkdocs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%85%B6%E4%BB%96/Markdown/" class="md-nav__link">
        Markdown
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1 绪论
  </a>
  
    <nav class="md-nav" aria-label="1 绪论">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 数据结构基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2 算法的基本概念
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2 线性表
  </a>
  
    <nav class="md-nav" aria-label="2 线性表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 线性表的基本概念和基本操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 顺序表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 链表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3 栈和队列
  </a>
  
    <nav class="md-nav" aria-label="3 栈和队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 栈
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 队列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 栈和队列的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    3.4 特殊矩阵压缩存储
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4 串
  </a>
  
    <nav class="md-nav" aria-label="4 串">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 串的存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 串的模式匹配
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5 树
  </a>
  
    <nav class="md-nav" aria-label="5 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    5.1 树的基础知识和性质
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    5.2 二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    5.3 二叉树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    5.4 线索二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    5.5 树的存储结构和遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#56" class="md-nav__link">
    5.6 二叉排序树，平衡二叉树，哈夫曼树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#57" class="md-nav__link">
    5.7 红黑树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6 图
  </a>
  
    <nav class="md-nav" aria-label="6 图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 图的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 图的表示法和基本操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-bfs-dfs" class="md-nav__link">
    6.3 bfs &amp;&amp; dfs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 最小生成树和最短路
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    6.5 有向无环图与应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#66" class="md-nav__link">
    6.6 并查集
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7 查找
  </a>
  
    <nav class="md-nav" aria-label="7 查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71" class="md-nav__link">
    7.1 基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72" class="md-nav__link">
    7.2 查找算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73-b" class="md-nav__link">
    7.3 B树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74-b" class="md-nav__link">
    7.4 B+树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75" class="md-nav__link">
    7.5 散列查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    8 排序
  </a>
  
    <nav class="md-nav" aria-label="8 排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81" class="md-nav__link">
    8.1 基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82" class="md-nav__link">
    8.2 插入排序：插入排序和希尔排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83" class="md-nav__link">
    8.3 交换排序：冒泡排序和快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84" class="md-nav__link">
    8.4 选择排序：简单选择排序和堆排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85" class="md-nav__link">
    8.5 归并排序和基数排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#87" class="md-nav__link">
    8.7 外部排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    总结
  </a>
  
    <nav class="md-nav" aria-label="总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/hucorz/myDoc/edit/master/docs/笔记/数据结构.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



<h1 id="_1">数据结构<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">算法可视化</a> 具体实现方式可能有出入</p>
<p><a href="https://www.bilibili.com/video/BV1b7411N798?spm_id_from=333.999.0.0">王道计算机考研 数据结构_哔哩哔哩_bilibili</a> </p>
<h2 id="1">1 绪论<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 数据结构基本概念<a class="headerlink" href="#11" title="Permanent link">&para;</a></h3>
<p>数据结构三要素：</p>
<ul>
<li>逻辑结构</li>
<li>物理结构</li>
<li>数据的运算</li>
</ul>
<p>数据逻辑结构：</p>
<ul>
<li>集合</li>
<li>线性</li>
<li>树形</li>
<li>图</li>
</ul>
<p>数据存储结构：</p>
<ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储（哈希存储）</li>
</ul>
<h3 id="12">1.2 算法的基本概念<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<p>算法五个特性：</p>
<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
<p>好算法的特质：</p>
<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率和低存储</li>
</ul>
<p>时间复杂度：常对幂指阶</p>
<p><span class="arithmatex">\(O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\)</span> </p>
<p>空间复杂度：空间复杂度是指算法需要的辅助空间的复杂度</p>
<p>递归时的空间复杂度，<span class="arithmatex">\(O(mn)\)</span> ，<span class="arithmatex">\(O(m)\)</span> 是每次递归中定义的变量的空间复杂度，<span class="arithmatex">\(O(n)\)</span> 是递归深度复杂度</p>
<h2 id="2">2 线性表<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 线性表的基本概念和基本操作<a class="headerlink" href="#21" title="Permanent link">&para;</a></h3>
<p>线性表的基本操作：创销，增删改查</p>
<h3 id="22">2.2 顺序表<a class="headerlink" href="#22" title="Permanent link">&para;</a></h3>
<p>顺序存储的线性表</p>
<p>实现方式：静态分配，动态分配</p>
<h3 id="23">2.3 链表<a class="headerlink" href="#23" title="Permanent link">&para;</a></h3>
<ul>
<li>单链表：带头结点和不带头结点</li>
<li>不带头结点时，对第一位结点操作有时要特殊处理</li>
<li>指定结点的前插操作（给一个结点和要插入的数据），可以在结点后面插入然后交换两者的数据</li>
<li>指定结点的删除操作，得到后继结点的数据并删除后继结点</li>
<li>头插可以用于链表的逆置</li>
<li>双链表</li>
<li>循环链表</li>
<li>循环单链表</li>
<li>循环双链表</li>
<li>静态链表</li>
</ul>
<h2 id="3">3 栈和队列<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="31">3.1 栈<a class="headerlink" href="#31" title="Permanent link">&para;</a></h3>
<p>LIFO</p>
<p>栈的实现：</p>
<ul>
<li>顺序实现</li>
<li>初始化 top = -1</li>
<li>初始化 top = 0</li>
<li>共享栈</li>
<li>链式实现，用单链表实现，头插，头删</li>
</ul>
<p>卡特兰数：
$$
\frac{1}{n+1}C^n_{2n}
$$</p>
<h3 id="32">3.2 队列<a class="headerlink" href="#32" title="Permanent link">&para;</a></h3>
<p>FIFO</p>
<p>队列的实现:</p>
<ul>
<li>顺序实现</li>
<li>设置队首和队尾指针，队尾指向队尾元素的下一个</li>
<li>判断为空， rear == front</li>
<li>判断队列空或满<ul>
<li>(rear + 1) % size == front（循环队列），留一个位置的原因是为了不和判断为空冲突</li>
<li>定义队列长度的变量，定义的话队列可以多一个空间，且一个 int 占用的空间很可能比存储的队列元素小</li>
<li>定义 tag 表示上一次操作是插入还是删除，0 表示删除，1 表示插入；tag 初始化为 0（只有插入才可能导致队空）</li>
</ul>
</li>
<li>队列元素个数 ：(rear + size - front) % size</li>
<li>链式实现</li>
<li>定义头指针和尾指针</li>
<li>尾插首删</li>
</ul>
<p>双端队列：</p>
<ul>
<li>队首和队尾都可以插入和删除</li>
<li>输入受限的双端队列：一端插入，双端输出</li>
<li>输出受限的双端队列，一端输出，双端输出</li>
</ul>
<h3 id="33">3.3 栈和队列的应用<a class="headerlink" href="#33" title="Permanent link">&para;</a></h3>
<p>栈的应用：</p>
<ul>
<li>括号匹配</li>
<li>表达式求值</li>
<li>波兰表达式（前缀表达式），逆波兰表达式（后缀表达式）；</li>
<li>计算后缀表达式时栈中存放操作数，从左往右扫描后缀表达式；</li>
<li>计算前缀表达式时存放操作数，从右往左扫描前缀表达式，需要注意除法和减法时操作数运算的顺序和后缀表达式不一样；</li>
<li>中缀表达式转换后缀表达式时栈中存放运算符和括号，弹出优先级大于或等于要压栈的运算符，遇到右括号就都弹出直到遇到左括号</li>
<li>中缀表达式的计算：中缀转后缀，计算后缀；要用到 2 个栈一起操作</li>
<li>递归，函数调用时在栈中压入下一条指令的地址和函数中需要的变量</li>
</ul>
<p>队列的应用：</p>
<ul>
<li>树的层次遍历</li>
<li>图的bfs</li>
<li>操作系统分配系统资源，FCFS，first come first server</li>
</ul>
<h3 id="34">3.4 特殊矩阵压缩存储<a class="headerlink" href="#34" title="Permanent link">&para;</a></h3>
<p>二维数组的行优先和列优先</p>
<p>对称矩阵：只存储对角线和上或下三角区，然后用行优先或者列优先存储</p>
<p>三角矩阵：和对称矩阵类似，上三角矩阵多存储一个下三角中的常数，下三角类似</p>
<p>三对角矩阵（带状矩阵）：只存储 <span class="arithmatex">\(|i-j| &lt;= 1\)</span> 的元素，除了第一行和最后一行每行都有三个元素</p>
<p>稀疏矩阵：三元组，十字链表</p>
<h2 id="4">4 串<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 串的存储结构<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<ul>
<li>顺序存储</li>
<li>链式存储</li>
</ul>
<h3 id="42">4.2 串的模式匹配<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<p>主串，子串，模式串</p>
<p>朴素的匹配算法复杂度：<span class="arithmatex">\(O(mn)\)</span> </p>
<p>KMP：字符串下标从 0 开始</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 字符串下标从 0 开始</span>
<span class="c1">// next</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">getNext</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="w"></span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// KMP</span>
<span class="c1">// 主体字符串 匹配字符串</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">KMP</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 返回存在与 p 相同的字串的位置</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>KMP 优化：nextval 数组</p>
<h2 id="5">5 树<a class="headerlink" href="#5" title="Permanent link">&para;</a></h2>
<p>要注意不要把树的性质，二叉树的性质，完全二叉树的性质搞混，当然，二叉树也有树的性质，完全二叉树也有二叉树的性质</p>
<h3 id="51">5.1 树的基础知识和性质<a class="headerlink" href="#51" title="Permanent link">&para;</a></h3>
<p>基础知识：</p>
<ul>
<li>
<p>树的概念</p>
</li>
<li>
<p>祖先节点，子孙结点，父节点，孩子结点，兄弟结点，堂兄弟结点</p>
</li>
<li>
<p>路径（从上到下,兄弟结点之间不存在路径），路径长度，树的路径长度（根到所有结点路径长度之和）</p>
</li>
<li>
<p>结点的层次（深度），度，树的高度（深度），树的度（各结点的度的最大值）</p>
</li>
<li>
<p>有序树（不可以交换），无序树</p>
</li>
<li>
<p>森林</p>
</li>
</ul>
<p>树的性质</p>
<ul>
<li>结点数 = 总度数 + 1</li>
<li>度为 m 的树 和 m 叉树的区别，m 叉树的度不一定为 m</li>
<li>度为 m 的树第 i 层至多有 <span class="arithmatex">\(m^{i-1}\)</span> 各结点</li>
<li>高度为 h 的 m 叉树至多有 <span class="arithmatex">\(\frac{m^h-1}{m-1}\)</span> </li>
<li>高度为 h 的 m 叉树至少有 h 个结点，高度为 h，度为 m 的树至少有 h+m-1 个结点</li>
<li>n 个结点的 m 叉树的最小高度 <span class="arithmatex">\(ceil(\ \ log_m(n(m-1)+1)\ \ )\)</span> </li>
</ul>
<h3 id="52">5.2 二叉树<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<p>二叉树特点：</p>
<ul>
<li>每个节点至多只有两棵子树</li>
<li>二叉树是有序树</li>
</ul>
<p>特殊的二叉树:</p>
<ul>
<li>满二叉树，不存在度为 1 的结点</li>
<li>完全二叉树 ，至多只有一个度为 1 的结点，只有一个孩子的结点一定是有左孩子</li>
<li>二叉排序树</li>
<li>平衡二叉树，不要求是二叉排序树</li>
</ul>
<p>二叉树性质：</p>
<ul>
<li>树的性质</li>
<li><span class="arithmatex">\(n=n_0+n_1+n_2,n=2n_2+n_1+1\)</span>  得到  <span class="arithmatex">\(n_0 = n_2 + 1\)</span>  </li>
</ul>
<p>完全二叉树性质：</p>
<ul>
<li>高度 <span class="arithmatex">\(h=ceil(\ log_2(n+1)\ ) 或 floor(\ log_2n\ )+1\)</span> </li>
<li><span class="arithmatex">\(n_1=0或1\)</span></li>
<li><span class="arithmatex">\(n_0=n_2+1\)</span> 得 <span class="arithmatex">\(n_0+n_2\)</span> 一定是奇数</li>
<li>若完全二叉树有 2k 个结点，则 <span class="arithmatex">\(n_1=1,n_0=k,n_2=k-1\)</span>，若完全二叉树有 2k-1 个结点，则 <span class="arithmatex">\(n_1=0,n_0=k,n_2=k-1\)</span></li>
</ul>
<p>二叉树的存储结构</p>
<ul>
<li>顺序存储 </li>
<li>链式存储 </li>
<li>n个结点有 2n 个指针，n-1 个没有指向 NULL，所以有 n+1 个指向 NULL</li>
<li>二叉链表，三叉链表（带父结点）</li>
</ul>
<h3 id="53">5.3 二叉树的遍历<a class="headerlink" href="#53" title="Permanent link">&para;</a></h3>
<p>层次遍历：队列</p>
<p>先序遍历：前缀表达式</p>
<p>中序遍历中：中缀表达式（无括号）</p>
<p>后序遍历：后缀表达式</p>
<p>非递归的代码实现方式：利用栈；后续遍历的非递归比较难</p>
<p>由遍历序列构造二叉树</p>
<ul>
<li>前序+中序</li>
<li>后序+中序</li>
<li>层序+中序</li>
</ul>
<h3 id="54">5.4 线索二叉树<a class="headerlink" href="#54" title="Permanent link">&para;</a></h3>
<p><strong>二叉树的线索化和线索二叉树的遍历的代码</strong></p>
<p>增加 2 个标志位表示左右孩子指针是否是线索，注意在线索二叉树遍历时遍历左右子树时要判断是否是前后继（如果不判断，在前序遍历时会绕圈）</p>
<p>中序线索二叉树</p>
<p>先序线索二叉树</p>
<p>后序线索二叉树</p>
<p>中序前驱，中序后继</p>
<p>前序前驱，前序后继</p>
<p>后序前驱，后序后继</p>
<p>二叉树的线索化：</p>
<ul>
<li>前序线索化时要注意判断 tag；</li>
<li>函数体主要由 2 个线索化左右子树的递归调用组成，还有利用参数的 pre 建立 pre 的后继 和 当前结点的前驱；不同的遍历方式顺序不同</li>
</ul>
<p>线索二叉树中找前序和后继：</p>
<ul>
<li>中序</li>
<li>先序：找前驱结点如果没有父节点找不到，如果有父节点需要分四种情况（第四种根结点）</li>
<li>后序：找后继序也需要三叉链表，分四种情况（第四种根结点）</li>
</ul>
<h3 id="55">5.5 树的存储结构和遍历<a class="headerlink" href="#55" title="Permanent link">&para;</a></h3>
<p>存储结构：</p>
<ul>
<li>双亲表示法（顺序存储），增加结点，删除结点</li>
<li>孩子表示法（顺序+链式）</li>
<li>孩子兄弟表示法（链式存储），两个指针：第一个孩子和右兄弟指针（树和二叉树的转换，森林和二叉树的转换）</li>
</ul>
<p>树的遍历：</p>
<ul>
<li>先根遍历（和转换为二叉树后的先序遍历一样 ）</li>
<li>后根遍历（和转换为二叉树后的中序遍历一样 ）</li>
<li>层次遍历（队列，bfs）</li>
</ul>
<p>森林的遍历：</p>
<ul>
<li>先序遍历，依序对子树进行先序遍历（和转换为二叉树后的先序遍历一样 ）</li>
<li>中序遍历，依序对子树进行后根遍历（和转换为二叉树后的中 序遍历一样 ）</li>
</ul>
<h3 id="56">5.6 二叉排序树，平衡二叉树，哈夫曼树<a class="headerlink" href="#56" title="Permanent link">&para;</a></h3>
<p>二叉排序树（BST）：</p>
<ul>
<li>构造，查找，增加</li>
<li>删除：要删除的结点时叶子节点，只有左子树，只有右子树，左右子树都有（把右子树最小的数或者左子树最大的数搬上来，即中序遍历中的直接前驱和直接后继）</li>
<li>平均查找长度（ASL），查找失败的ASL</li>
</ul>
<p>平衡二叉树（AVL，发明人首字母组成 或者 BBT）：二叉排序树的特殊形式，左子树和右子树的高度差不超过 1</p>
<ul>
<li>平衡因子，结点的平衡因子=左子树高-右子树高，AVL 中所有结点的平衡因子只有 -1，0，1</li>
<li>最小不平衡子树</li>
<li>调整最小不平衡子树</li>
<li>LL，右旋</li>
<li>RR，左旋</li>
<li></li>
<li>LR，先左旋，再右旋</li>
<li>
<p>RL，先右旋，再左旋</p>
</li>
<li>
<p>查找效率分析：<span class="arithmatex">\(O(log_2n)\)</span> :</p>
</li>
</ul>
<p>假设 <span class="arithmatex">\(n_h\)</span> 表示高度为 <span class="arithmatex">\(h\)</span> 的平衡二叉树的的最少结点数，有 <span class="arithmatex">\(n_0=0, n_1=1, n_2=2, n_h=n_{h-1}+n_{h-2}+1\)</span> </p>
<p>哈夫曼树（是二叉树）：</p>
<ul>
<li>结点的权，结点的带权路径长度：根到结点的路径长度 x 结点权值，树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和</li>
<li>哈夫曼树：WPL最小的二叉树，也称最优二叉树</li>
<li>哈夫曼树的构造：先选 2 个权值最小的结点加起来变成一个新的结点 .....</li>
<li>哈夫曼树的总结点树为 <span class="arithmatex">\(2n-1\)</span>，n 个叶子结点，多出来 n-1 个新结点；哈夫曼树不存在度为 1 的结点；哈夫曼树并不唯一，但 WPL 一定最优</li>
<li>哈夫曼编码，非前缀编码会有歧义</li>
</ul>
<h3 id="57">5.7 红黑树<a class="headerlink" href="#57" title="Permanent link">&para;</a></h3>
<p>红黑树是满足以下红黑性质的二叉排序树（不是二叉平衡树）：</p>
<ul>
<li>每个结点是红色或者黑色的</li>
<li>根结点是黑色的</li>
<li>叶结点（虚构结点，NULL）都是黑色的</li>
<li>不存在相邻的红结点</li>
<li>对每个结点，从该结点到任一叶结点的简单路径上的黑结点的数量相同（黑高）；根的黑高是红黑树的黑高</li>
</ul>
<p>结论1：</p>
<ul>
<li>从根到叶结点的最长路径不大于最短路径的2倍</li>
<li>从根到任一叶结点的简单路径最短时，这条路径必然全是黑结点</li>
<li>当某条路径最长时，这条路径是由黑结点和红结点相间构成的，红结点和黑结点的数量相同</li>
</ul>
<p>结论2：</p>
<ul>
<li>有n个内部结点的红黑树的高度 <span class="arithmatex">\(h&lt;=2log_2(n+1)\)</span> ；证：根的黑高至少为 h/2，于是有 <span class="arithmatex">\(n&gt;=2^{h/2}-1\)</span> 即可</li>
</ul>
<p>综上：红黑树是适度平衡的，由AVL的高度平衡变成了任一结点的左右子树的高度不相差2倍</p>
<p>红黑树的插入结点<span class="arithmatex">\(z\)</span>：</p>
<ul>
<li>用二叉查找树插入法插入，并把 <span class="arithmatex">\(z\)</span> 涂成红色，如果 <span class="arithmatex">\(z\)</span> 父结点是黑色的，无需做调整</li>
<li>如果 <span class="arithmatex">\(z\)</span> 是根结点，涂黑然后树的黑高 加一</li>
<li>如果 <span class="arithmatex">\(z\)</span> 不是根结点，并且 <span class="arithmatex">\(z.p\)</span> 是红色的（<span class="arithmatex">\(z.p.p\)</span> 是黑色的），分为以下三种情况：<ul>
<li>情况一：<span class="arithmatex">\(z\)</span> 的叔结点 <span class="arithmatex">\(y\)</span> 是黑色的，且 <span class="arithmatex">\(z\)</span> 是右孩子；解决办法：先左旋（变成了情况二），再右旋</li>
<li>情况二：<span class="arithmatex">\(z\)</span> 的叔结点 <span class="arithmatex">\(y\)</span> 是黑色的，且 <span class="arithmatex">\(z\)</span> 是左孩子；解决办法：右旋，<span class="arithmatex">\(z.p\)</span> 和 <span class="arithmatex">\(z.p.p\)</span> 要互换颜色</li>
<li>如果 <span class="arithmatex">\(z.p\)</span> 是 <span class="arithmatex">\(z.p.p\)</span> 的右孩子，则和上面的两种情况是对称的</li>
<li>情况三：如果 <span class="arithmatex">\(z\)</span> 的叔结点 <span class="arithmatex">\(y\)</span> 是红色的；不管 <span class="arithmatex">\(z\)</span> 是左孩子还是右孩子，把爷结点变成红色，把父结点和叔结点变成黑色，然后爷结点变成新的 <span class="arithmatex">\(z\)</span> 继续处理，即 <span class="arithmatex">\(z\)</span> 上移了两层</li>
</ul>
</li>
</ul>
<p>红黑树的删除：<a href="https://blog.csdn.net/qq_40843865/article/details/102498310?utm_source=app&amp;app_version=5.5.0">可以参考的blog</a> </p>
<ul>
<li>用二叉查找树的删除结点的办法</li>
<li>第1种情况：如果被删除结点有左右孩子，就把其中序遍历的后继（或者前驱）结点的数值与其替换，问题变换成下面2中情况</li>
<li>第2种情况：待删结点只有左孩子或者右孩子，那么只有可能待删除的是黑色，左孩子或者右孩子是一个红色结点，把结点删了然后把孩子换上来变成黑色即可</li>
<li>第3种情况：待删结点没有孩子<ul>
<li>待删结点没有孩子并且是红色的，直接删除即可</li>
<li>待删结点是黑色的，删除待删结点后变成 null 结点再套一层黑色 （或者是双黑结点）代替，叫做 <span class="arithmatex">\(x\)</span>，问题变为如何把多的那层黑色消去，区别在于 <span class="arithmatex">\(x\)</span> 的兄弟结点 <span class="arithmatex">\(w\)</span> 以及 <span class="arithmatex">\(w\)</span> 的孩子结点的颜色<ul>
<li>情况1：<span class="arithmatex">\(w\)</span> 是红色的，那么 <span class="arithmatex">\(w\)</span> 必然是有黑色左右孩子，处理办法是交换 <span class="arithmatex">\(x.p\)</span> 和 <span class="arithmatex">\(w\)</span> 的颜色，既然后进行一次单向旋转，问题变为情况2，3 或 4</li>
<li>情况2：<span class="arithmatex">\(w\)</span> 是黑色的，<span class="arithmatex">\(w\)</span> 的左孩子是红色的，<span class="arithmatex">\(w\)</span> 的右孩子是黑色的；即红色结点是爷结点的右孩子的左孩子，处理办法是先交换 <span class="arithmatex">\(w\)</span> 和其左孩子的颜色再 RL，其中右旋过后其实就变成了情况3</li>
<li>情况3：<span class="arithmatex">\(w\)</span> 是黑色的，<span class="arithmatex">\(w\)</span> 的右孩子是红色的；处理办法是先交换 <span class="arithmatex">\(w\)</span> 和 <span class="arithmatex">\(x.p\)</span> 的颜色，再把 <span class="arithmatex">\(w\)</span> 右孩子变为黑色再 RR(左单旋)，然后 <span class="arithmatex">\(x\)</span> 可以变回正常黑色</li>
<li>情况4：<span class="arithmatex">\(w\)</span> 是黑色的且两个孩子结点也都是黑色（或者说无红色子结点）的处理办法是把 <span class="arithmatex">\(w\)</span> 和 <span class="arithmatex">\(x\)</span> 去掉一层黑色，给 <span class="arithmatex">\(x.p\)</span> 加上一层黑色作为新的 <span class="arithmatex">\(x\)</span> 去处理（如果 <span class="arithmatex">\(x.p\)</span> 是红色的就直接涂黑，如果是黑色的就作为双黑结点继续处理）；如果一直处理到根结点，把多的一层黑色直接舍去</li>
<li>其他对称情况类似</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6">6 图<a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 图的基本概念<a class="headerlink" href="#61" title="Permanent link">&para;</a></h3>
<p>线性表可以是空表，树可以是空树，图不可以是空，即 V 一定是非空集，E 可以为空集</p>
<p>无向图，有向图：顶点的有序和无序；弧（有向边）</p>
<p>简单图：无重边，无环；多重图：非简单图</p>
<p>完全图：也称简单完全图，有向与无向</p>
<p>子图：从 V 中取子集，E 做相应的子集；生成子图：<span class="arithmatex">\(V(G')=V(G)\)</span> </p>
<p>连通：无向图中 v 和 w有路径存在；强连通：无向图中 v 和 w有路径存在，w 到 v 有路径存在</p>
<p>连通图（无向图），n 个点最少有 n-1 条边，最多有 <span class="arithmatex">\(C_{n-1}^2\)</span> 即（<span class="arithmatex">\(\frac{(n-1)(n-2)}{2}\)</span>）条边，n-1个顶点构成完全图</p>
<p>强连通图（有向图），n 个点最少有 n 条边</p>
<p>连通分量：无向图中的极大连通子图称为连通分量</p>
<p>强连通分量：有向图中的极大强连通子图称为连通分量</p>
<p>生成树：连通图中，包含连通图的全部顶点，且是极小连通子图；少一条边就非连通，多就有环</p>
<p>生成森林：非连通图中，连通分量的生成树构成了生成森林</p>
<p>邻接，关联：无向图中 <span class="arithmatex">\((v, v')\)</span>，<span class="arithmatex">\(v,v'\)</span> 互为邻接点，<span class="arithmatex">\((v, v')\)</span> 和 <span class="arithmatex">\(v,v'\)</span> 相关联；有向图中 <span class="arithmatex">\(&lt;v, v'&gt;\)</span>，称 <span class="arithmatex">\(v\)</span> 邻接到 <span class="arithmatex">\(v'\)</span>，<span class="arithmatex">\(&lt;v, v'&gt;\)</span> 和 <span class="arithmatex">\(v,v'\)</span> 相关联</p>
<p>度（TD），出度（OD），入度（ID）；有向图的度为 入度 + 出度</p>
<p>无向图：<span class="arithmatex">\(\sum TD(V_i)=2|E|\)</span> </p>
<p>有向图：<span class="arithmatex">\(\sum OD(V_i)=\sum ID(V_i)=|E|\)</span> </p>
<p>边的权，带权图（也叫网），带权路径长度</p>
<p>路径：顶点序列</p>
<p>回路</p>
<p>简单路径：顶点不重复出现；简单回路：除了起点和终点，顶点不重复</p>
<p>距离：最短路径长度或无穷</p>
<p>稀疏图，稠密图</p>
<p>树：不存在回路且连通的图；森林：</p>
<p>有向树：只有一个顶点的入度为0，其他顶点的入度都为 1 </p>
<h3 id="62">6.2 图的表示法和基本操作<a class="headerlink" href="#62" title="Permanent link">&para;</a></h3>
<p>邻接矩阵法（空间复杂度 <span class="arithmatex">\(O(v^2)\)</span>），假设矩阵为 <span class="arithmatex">\(A\)</span>，则 <span class="arithmatex">\(A*A\)</span> 表示路径长度为 2 的路径数目，<span class="arithmatex">\(A^n\)</span> 表示路径长度为 n </p>
<p>邻接表（空间复杂度有向图 <span class="arithmatex">\(O(V+E)\)</span>，无向图 <span class="arithmatex">\(O(V+2E)\)</span>）</p>
<p>十字链表（存储有向图，空间复杂度 <span class="arithmatex">\(O(V+E)\)</span>）</p>
<p>邻接多重表（存储无向图，空间复杂度 <span class="arithmatex">\(O(V+E)\)</span>）</p>
<h3 id="63-bfs-dfs">6.3 bfs &amp;&amp; dfs<a class="headerlink" href="#63-bfs-dfs" title="Permanent link">&para;</a></h3>
<p>bfs：队列，空间复杂度 <span class="arithmatex">\(O(V)\)</span> （队列的长度） 时间复杂度 邻接矩阵 <span class="arithmatex">\(O(V^2)\)</span>，邻接表 <span class="arithmatex">\(O(V+E)\)</span> </p>
<p>广度优先生成树（不是最小的，且如果用邻接表不唯一）</p>
<p>广度优先生成森林（图中有多个连通分量时）</p>
<p>dfs：空间复杂度 <span class="arithmatex">\(O(V)\)</span>（函数递归调用栈） 时间复杂度 邻接矩阵 <span class="arithmatex">\(O(V^2)\)</span>，邻接表 <span class="arithmatex">\(O(V+E)\)</span> </p>
<p>深度优先生成树（不是最小的，且如果用邻接表不唯一）</p>
<p>深度优先生成森林（图中有多个连通分量时）</p>
<p>判环用 拓扑排序 和 dfs，如果在 dfs 要访问的元素已经访问过并且还在栈中时，说明有环；bfs 不行的原因是可能有多个结点指向该结点，不一定是因为有环</p>
<h3 id="64">6.4 最小生成树和最短路<a class="headerlink" href="#64" title="Permanent link">&para;</a></h3>
<p>最小生成树（MST），非连通图只有生成森林</p>
<ul>
<li>
<p>Prim：<span class="arithmatex">\(O(V^2)\)</span> </p>
</li>
<li>
<p>Kruskal（并查集）：<span class="arithmatex">\(O(ElogE)\)</span> </p>
</li>
</ul>
<p>最短路径</p>
<ul>
<li>各顶点间最短路</li>
<li>Floyd（带权图，无权图），可以用 path 记录中转点来记录路径，时间复杂度 <span class="arithmatex">\(O(V^3)\)</span>，空间复杂度 <span class="arithmatex">\(O(V^2)\)</span> </li>
<li>单源最短路问题</li>
<li>BFS（无权图）</li>
<li>Dijkstra（带权图，无权图），注意与 Prime 算法的区别在 dis 的含义和松弛操作；记录每个结点的前驱来记录路径，时间复杂度 <span class="arithmatex">\(O(V^2)\)</span>。不适用于负权边</li>
</ul>
<h3 id="65">6.5 有向无环图与应用<a class="headerlink" href="#65" title="Permanent link">&para;</a></h3>
<p>有向无环图（DAG，Directed acyclic graph）</p>
<ul>
<li>描述表达式，并进行图的优化</li>
<li>AOV 网（Activity On Vertex NetWork），用 vertex 表示活动</li>
<li>拓扑排序：</li>
<li>算法：入度的统计可以用一个数组indegree实现，E是删除结点时更新indegree需要的时间，用队列或栈记录indegree为0的结点</li>
<li>
<p>时间复杂度，邻接表 <span class="arithmatex">\(O(V+E)\)</span>，邻接矩阵 <span class="arithmatex">\(O(V^2)\)</span>；逆拓扑排序（每次删除出度为 0 的结点）：邻接表 <span class="arithmatex">\(O(VE)\)</span>，邻接矩阵 <span class="arithmatex">\(O(V^2)\)</span>，逆邻接表 <span class="arithmatex">\(O(V+E)\)</span> ；使用逆邻接表即可实现拓扑排序的正逆；使用 dfs 求拓扑序 <a href="https://blog.csdn.net/hjl_heart/article/details/88080983">用DFS解拓扑排序</a> </p>
</li>
<li>
<p>AOE 网（Activity On Edge  NetWork），用 edge 表示活动，结点表示事件，只有一个入度为 0 的顶点（源点），一个出度为 0 的顶点（汇点）；源点到汇点的最长路径叫关键路径（可能有多条），上面的活动叫关键活动 </p>
</li>
<li>事件的最早发生时间（ve，按照拓扑序求 max），活动的最早开始时间（e，弧起始点的 ve）</li>
<li>事件最迟发生时间（vl，按照逆拓扑序求 min），活动最迟开始时间（l）（  <strong>min（弧终点事件的最迟发生时间-活动时间）</strong>）</li>
<li>活动的时间余量（d），活动的最早开始时间和最迟开始时间相同的活动（d=0）是关键活动</li>
</ul>
<h3 id="66">6.6 并查集<a class="headerlink" href="#66" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w">  </span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">unite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fa</span><span class="p">[</span><span class="n">fx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fy</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">same</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="7">7 查找<a class="headerlink" href="#7" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 基本概念<a class="headerlink" href="#71" title="Permanent link">&para;</a></h3>
<p>查找，查找表（数据集合），关键字（唯一标识数据的值）</p>
<p>静态查找表（只会查找），动态查找表（会进行插入和删除）,静态查找表用顺序存储，动态查找表用二叉排序树</p>
<p><strong>平均查找长度 ASL</strong> </p>
<h3 id="72">7.2 查找算法<a class="headerlink" href="#72" title="Permanent link">&para;</a></h3>
<p>顺序查找</p>
<ul>
<li>哨兵（放在 a[0]，从尾部往前查找）</li>
<li>分析ASL，<span class="arithmatex">\(ASL_{成功}=(n+1)/2,ASL_{失败}=n+1\)</span> </li>
<li>顺序查找的优化</li>
<li>有序表的顺序查找可以提前停止，用判定树分析，<span class="arithmatex">\(ASL_{失败}=n/2+n/(n+1)\)</span> </li>
<li>被查找概率大的放在靠前的位置</li>
</ul>
<p>折半查找</p>
<ul>
<li>仅适用于有序的顺序表</li>
<li>查找效率分析 ASL，<span class="arithmatex">\(O(long_2n)\)</span></li>
<li>折半查找判定树的树高 <span class="arithmatex">\(h=ceil(log_2(n+1))\)</span> ，且是二叉排序树，且平衡，失败结点有 n+1</li>
</ul>
<p>分块查找 / 索引顺序查找</p>
<ul>
<li>块内无序，块间有序</li>
<li>先查索引表，可顺序，可二分（很麻烦）</li>
<li>查找效率分析，有 b 块，每块 s 个元素</li>
<li>顺序查找索引表，<span class="arithmatex">\(ASL=\frac{b+1}{2}+\frac{s+1}{2}\)</span>，当 <span class="arithmatex">\(s=\sqrt{n}\)</span> 时，ASL 最小 = <span class="arithmatex">\(\sqrt{n} + 1\)</span> </li>
<li>折半查找索引表，<span class="arithmatex">\(ASL=ceil(log_2(b+1))+\frac{s+1}{2}\)</span> </li>
</ul>
<h3 id="73-b">7.3 B树<a class="headerlink" href="#73-b" title="Permanent link">&para;</a></h3>
<p>二叉查找树变为 m 叉查找树，结点中的关键字是有序的，所以可以二分</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Elemtype</span><span class="w"> </span><span class="n">keys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="c1">// 最多4个关键字</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="o">*</span><span class="w"> </span><span class="n">child</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"> </span><span class="c1">// 4个关键字最多5个分叉，最多5个孩子</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">    </span><span class="c1">// 记录结点中有几个关键字</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>保证查找效率：</p>
<ul>
<li>规定 m 叉查找树中除了根结点外，任何结点至少有 <span class="arithmatex">\(ceil(m/2)\)</span> 个分叉，<span class="arithmatex">\(ceil(m/2)-1\)</span> 个关键字</li>
<li>对于任何一个结点其子树的高度要相同</li>
</ul>
<p>B树定义：</p>
<p><img src="../img/数据结构/7.3B树定义1.png" width=80%></p>
<p><img src="../img/数据结构/7.3B树定义2.png" width=80%></p>
<p>含 n 个关键字的 m 阶 B 树的最小高度：
$$
n&lt;=(m-1)(1+m+m^2+...+m^h) \
h &gt;= log_m(n+1)
$$
 最大高度：</p>
<p>思路一：</p>
<p>让各层分叉尽可能的小，第一层 2 个分叉，其他结点 <span class="arithmatex">\(ceil(m/2)\)</span> 分叉，所以各层结点数：<span class="arithmatex">\(1,2,2ceil(m/2),...2ceil(m/2)^{h-2}\)</span>，则 <span class="arithmatex">\(h+1\)</span> 层共有叶子结点（失败结点）<span class="arithmatex">\(2ceil(m/2)^{h-1}\)</span> ；因为 n 个关键字的B树必有 n+1 个叶子结点（n个数字分成了 n+1 个区间），所以 <span class="arithmatex">\(n+1&gt;=2ceil(m/2)^{h-1}\)</span>，得 <span class="arithmatex">\(h&lt;=log_{ceil(m/2)}\frac{n+1}{2}+1\)</span>   </p>
<p>思路二：设 <span class="arithmatex">\(k=ceil(m/2)\)</span> </p>
<table>
<thead>
<tr>
<th></th>
<th>最少结点数</th>
<th>最少关键字数</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一层</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>第二层</td>
<td>2</td>
<td>2(k-1)</td>
</tr>
<tr>
<td>第三层</td>
<td>2k</td>
<td>2k(k-1)</td>
</tr>
<tr>
<td>....</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>第h层</td>
<td><span class="arithmatex">\(2k^{h-2}\)</span></td>
<td><span class="arithmatex">\(2k^{h-2}(k-1)\)</span></td>
</tr>
</tbody>
</table>
<p>h 层 m 阶 B 数至少包含关键字总数 <span class="arithmatex">\(1+2(k-1)+...+2k^{h-2}(k-1)=1+2(k^{h-1}-1) &lt;= n\)</span>，得  <span class="arithmatex">\(h&lt;=log_{ceil(m/2)}\frac{n+1}{2}+1\)</span>   </p>
<p>B 树的插入（王道视频P73，书P297）：</p>
<ul>
<li>如果只有根结点，就插入根结点，满了就分裂成 3 个结点（1个根结点 2 个子结点，根结点上传）</li>
<li>新元素一定要插入最底层的终端结点（保持失败结点在最底层的特性），满了也是分裂 </li>
</ul>
<p>B 树的删除（王道视频P73，书P298）：</p>
<ul>
<li>要删除的关键字在终端结点，结点中关键字大于 <span class="arithmatex">\(ceil(m/2)\)</span> 就直接删除</li>
<li>如果不在终端结点中就直接用前驱或者直接后继（是在终端结点中的）代替，替代不影响 关键字大于 <span class="arithmatex">\(ceil(m/2)\)</span> 的条件），如果小于了就让后继的后继（父节点下来，后继的后继当父节点）或者前驱的前驱（父节点下来，前驱的前驱当父节点）来填补，没的借就合并</li>
</ul>
<p><img alt="B树插入删除" src="../../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.3B%E6%A0%91%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4.png" /></p>
<h3 id="74-b">7.4 B+树<a class="headerlink" href="#74-b" title="Permanent link">&para;</a></h3>
<p>类比分块查找</p>
<p>定义2：非叶（形容词）根结点</p>
<p><img src="../img/数据结构/7.4B+树定义.png" width=80%></p>
<p>B+树的查找除了按照层次往下查找也可以按指针P顺序查找</p>
<p>B+树和B树的对比</p>
<p>m阶B+树：</p>
<ul>
<li>结点中n个关键字对应n个子树</li>
<li>除根结点外的结点的关键字数 <span class="arithmatex">\([\ ceil(m/2),m\ ]\)</span> </li>
<li>叶子结点包含全部的关键字，非叶子结点中出现过的关键字也会在叶子结点中</li>
<li>所有非叶子结点只起到索引作用，不包含该关键字的对应记录的存储地址</li>
</ul>
<p>m阶B树：</p>
<ul>
<li>结点中n个关键字对应n+1个子树</li>
<li>除根结点外的结点的关键字数 <span class="arithmatex">\([\ ceil(m/2)-1, m-1\ ]\)</span> </li>
<li>各结点的关键字不重复</li>
<li>结点包含了关键字对应的记录的存储地址</li>
</ul>
<p><img src="../img/数据结构/7.4B树B+树对比.png" width=80%></p>
<h3 id="75">7.5 散列查找<a class="headerlink" href="#75" title="Permanent link">&para;</a></h3>
<p>散列表=哈希表，散列函数=哈希函数，同义词，冲突，聚集</p>
<p>查找长度（如果是空，查找长度=0），计算 <span class="arithmatex">\(ASL_{成功}\)</span>，<span class="arithmatex">\(ASL_{失败}\)</span>（注意计算失败的时候主要和哈希函数有关和当前表内状态有关）</p>
<p>装填因子<span class="arithmatex">\(\alpha\)</span>=表中记录数/散列表长度 </p>
<p>常见散列函数：</p>
<ul>
<li>除留余数法，散列表长度为 m，除数取不大于 m 的最大质数 p，会让哈希数值域小于散列表长度，再用开放定址法可以恢复</li>
<li>直接定址法，做一个线性变换 H(key) = a*key+b</li>
<li>数字分析法，选取数码分布均匀的若干位作为散列地址</li>
<li>平方取中法，取平方值的中间几位作为散列地址</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li>拉链法，小优化：使链表有序，如果查找失败可以提前返回</li>
<li>开放定址法 <span class="arithmatex">\(H_i=(H(key)+d_i)\%m\)</span>，查找失败时对空位置的判断也算一次比较；在删除结点时要做标记，以便后面查找时继续探测</li>
<li>线性探测法，<span class="arithmatex">\(d_i=0,1,2,3,4...\)</span></li>
<li>平方探测法（二次探测法），<span class="arithmatex">\(d_i=0,1,-1,4,-4,9,-9...,k^2,-k^2\)</span> ，<span class="arithmatex">\(k&lt;=m/2\)</span>，散列表长度 m 必须是一个可以表示成 4j+3 的素数才可以探测到所有素数</li>
<li>伪随机序列法</li>
<li>再散列法，多准备几个散列函数</li>
</ul>
<p>注意在删除时要做标记，不然下次查找时可能会有问题</p>
<h2 id="8">8 排序<a class="headerlink" href="#8" title="Permanent link">&para;</a></h2>
<p>这部分要注意代码</p>
<h3 id="81">8.1 基本概念<a class="headerlink" href="#81" title="Permanent link">&para;</a></h3>
<p>空间和时间复杂度</p>
<p>算法的稳定性</p>
<p>分类：</p>
<ul>
<li>内部排序，数据都在内存中，关注时间空间复杂度</li>
<li>外部排序，数据太多，无法全部放入内存，还要关注使读/写磁盘次数更少</li>
</ul>
<h3 id="82">8.2 插入排序：插入排序和希尔排序<a class="headerlink" href="#82" title="Permanent link">&para;</a></h3>
<p>插入排序：</p>
<ul>
<li>每次将待排序的记录按照关键字大小插入前面已排好的子序列中</li>
<li>如果有哨兵，哨兵用来复制待排序的记录</li>
<li>空间复杂度 <span class="arithmatex">\(O(1)\)</span>，时间复杂度 <span class="arithmatex">\(O(n^2)\)</span> </li>
<li>稳定性：稳定</li>
<li>优化？：对前面已排好的子序列用折半查找，为了保证稳定性在找到之后还要继续找直到 low&gt;high，然后把 [low, i-1] 内的元素右移，时间复杂度 <span class="arithmatex">\(O(n^2)\)</span> </li>
<li>如果用链表存储，时间复杂度 <span class="arithmatex">\(O(n^2)\)</span> </li>
</ul>
<p>希尔排序：对插入排序的优化；由部分有序逼近全局有序</p>
<ul>
<li>由增量 <span class="arithmatex">\(d\)</span> 分成多个子表后对子表插入排序，然后缩小增量 <span class="arithmatex">\(d\)</span> 直到 <span class="arithmatex">\(d=1\)</span>；<span class="arithmatex">\(d\)</span> 建议初值为 <span class="arithmatex">\(n/2\)</span>，然后每次 <span class="arithmatex">\(d_{i+1}=d_i/2\)</span>； </li>
<li>空间复杂度：<span class="arithmatex">\(O(1)\)</span>；时间复杂度： <span class="arithmatex">\(O(n^{1.3}) 到 O(n^2)\)</span> </li>
<li>稳定性：不稳定</li>
<li>只能基于顺序表</li>
</ul>
<h3 id="83">8.3 交换排序：冒泡排序和快速排序<a class="headerlink" href="#83" title="Permanent link">&para;</a></h3>
<p>冒泡排序：</p>
<ul>
<li>每轮都找到一个未排序的数放到最前面（或者找最大的放后面）</li>
<li>时间复杂度：<span class="arithmatex">\(O(n^2)\)</span> ，空间复杂度：<span class="arithmatex">\(O(1)\)</span> </li>
<li>稳定性：稳定</li>
<li>冒泡排序适合链表</li>
<li>优化：某一趟没有交换就可以提前结束</li>
</ul>
<p>快速排序（重要  ）：</p>
<ul>
<li>在表中任取一个元素作为枢轴或基准，划分为左右 2 部分（实现时有一个 low 和 high 不断向内移动），然后递归</li>
<li>如果表原本就是有序或者逆序，时间复杂度：<span class="arithmatex">\(O(n^2)\)</span>，空间复杂度：<span class="arithmatex">\(O(n)\)</span>；如果基准元素选的好，时间复杂度：<span class="arithmatex">\(O(nlog_2n)\)</span>，空间复杂度：<span class="arithmatex">\(O(log_2n)\)</span> </li>
<li>枢轴的选取，选取头中尾三个元素选中间的，或者随机选择</li>
<li>稳定性：不稳定</li>
<li>一趟排序：可以确定多个元素的最终位置（比如第一趟确定1个，第二趟可以确定2个）；一次划分（partition）：只可以确定一个元素的最终位置</li>
</ul>
<h3 id="84">8.4 选择排序：简单选择排序和堆排序<a class="headerlink" href="#84" title="Permanent link">&para;</a></h3>
<p>选择排序：</p>
<ul>
<li>在待排序的表中找到最小的，然后和待排序的表中第一个元素调换</li>
<li>空间复杂度：<span class="arithmatex">\(O(1)\)</span>，时间复杂度：<span class="arithmatex">\((O(n^2))\)</span>，且无法提前停止，即在任何情况下时间复杂度不变；排序过程中移动次数很少</li>
<li>稳定性：不稳定</li>
<li>可以适用于链表</li>
</ul>
<p>堆排序（重要）：</p>
<ul>
<li>利用大根堆或小根堆实现；大根堆（大顶堆）：根结点的数大于左右子树</li>
<li>建立大根堆，检查非终端结点的编号 <span class="arithmatex">\(i&lt;=floor(n/2)\)</span>；编号从大到小检查，如果不 比自己孩子结点都大，与 2 个孩子中大的交换，交换后还要向下检查（可能会破坏下面的堆的性质）；注意建立大根堆时表的下标一般从 1 开始方便计算孩子的下标</li>
<li>堆排序：每一趟将最后一个元素换到堆顶；再调整大根堆（小元素下坠）</li>
<li>时间复杂度：<span class="arithmatex">\(O(nlog_2n)\)</span>，空间复杂度：<span class="arithmatex">\(O(1)\)</span> </li>
<li>建立初始大根堆的复杂度：<span class="arithmatex">\(O(n)\)</span> ，不超过 4n</li>
<li>稳定性：不稳定</li>
</ul>
<p>堆的插入和删除：以小根堆为例</p>
<ul>
<li>插入：放在表尾（堆低），往上提</li>
<li>删除：用堆底（表尾）的元素替换删除的位置，然后向下坠；要注意下坠的时候如果有2个孩子，每次下坠都要对比2次，一个孩子只需要对比一次</li>
</ul>
<h3 id="85">8.5 归并排序和基数排序<a class="headerlink" href="#85" title="Permanent link">&para;</a></h3>
<p>归并排序：一般都是 2 路归并</p>
<ul>
<li>将原序列拆成 2 部分进行递归归并排序</li>
<li>代码实现时有三个指针（int型），low，mid，high，开新的空间复制过去，在原列表中归并</li>
<li>2 个函数 MergeSort 和 Merge</li>
<li>时间复杂度：<span class="arithmatex">\(O(nlog_2n)\)</span>，空间复杂度：<span class="arithmatex">\(O(n)\)</span> （merge中的辅助空间）</li>
<li>稳定性：稳定</li>
</ul>
<p>基数排序：按个位先排好，再按十位排好 。。。。</p>
<ul>
<li>基数 <span class="arithmatex">\(r\)</span>：比如十进制就是 10，表示有 10 种不同的取值</li>
<li>排序时需要设置 <span class="arithmatex">\(r\)</span> 个辅助队列，<span class="arithmatex">\(Q_{r-1},...,Q_0\)</span>，按照权重低的到权重高的顺序，进行 <span class="arithmatex">\(d\)</span> 次分配再收集， <span class="arithmatex">\(d\)</span> 表示有几位</li>
<li>时间复杂度 <span class="arithmatex">\(O(d(n+r))\)</span>，一趟分配 <span class="arithmatex">\(O(n)\)</span>，一趟收集 <span class="arithmatex">\(O(r)\)</span>，空间复杂度 <span class="arithmatex">\(O(r)\)</span>，即 r 个辅助队列</li>
<li>稳定性：稳定</li>
<li>应用：按照学生年龄递减排序，权重 年&gt;月&gt;日，年月日越大，年龄越小；所以第一躺按分配，收集按 日 递增，即先收集 日 小的。。。基数 <span class="arithmatex">\(r\)</span> 在年月日是不同的</li>
<li>基数排序擅长解决的问题：数据可以方便的拆分为 d 组，并且 d 和 r 小的</li>
</ul>
<h3 id="87">8.7 外部排序<a class="headerlink" href="#87" title="Permanent link">&para;</a></h3>
<p>外部排序：</p>
<ul>
<li>外存和内存以块为单位读写</li>
<li>构造初始的归并段：在内存中开三块的空间，每次读入连续的 2 块进行归并排序，然后写回去，假设有 n 块，则得到 n/2 个归并段，一共读写了 2n 次；然后不断的归并成更大的段（这里要知道怎么用内存中三块的空间去归并，外存需要开额外的空间）</li>
<li>外部排序的时间开销=读写外存的时间+内部排序的时间（生成初始归并段）+内部归并所需时间；时间主要花在了读写外存上</li>
<li>总读写磁盘次数 = 文件总块数 *2* (归并趟数 + 1)（构造初始归并段+归并的趟数）</li>
<li>优化思路1：减少归并的趟数，可以使用多路归并，内存需要更多的缓冲区，空间换时间；假设有 r 个初始归并段，做 k 路归并</li>
</ul>
<p><img src="../img/数据结构/8.7多路归并优化.png" width=80%></p>
<ul>
<li>优化思路2：增加初始归并段的大小（内存需要的块数要变大），即减少初始归并段的数量 r</li>
</ul>
<p>败者树：</p>
<p>k 路归并 k 过大时会导致选出一个最小元素需要对比 k-1 次，败者树可以优化这个；败者树的结点存放失败者，最后多一个额外的结点存储冠军</p>
<p>有了败者树，选出最小元素只需要对比关键字 <span class="arithmatex">\(ceil(log_2k)\)</span> 次</p>
<p><img src="../img/数据结构/8.7败者树.png" width=80%></p>
<p>置换选择排序：</p>
<p>原本的办法，如果内存可容纳 <span class="arithmatex">\(l\)</span> 个记录，文件一共有 <span class="arithmatex">\(n\)</span> 个记录，则初始归并段的数量 <span class="arithmatex">\(r = n/l\)</span>；</p>
<p>置换选择排序时记录已经输出的最小数值 <span class="arithmatex">\(min\)</span>，每次输出最小的且大于 <span class="arithmatex">\(min\)</span> 的数，更新 <span class="arithmatex">\(min\)</span> 再读入新的；小于 <span class="arithmatex">\(min\)</span> 的留在内存内，直到内存内的都小于 <span class="arithmatex">\(min\)</span>；这样做每次得到的初始归并段长度并不一定相同</p>
<p><img src="../img/数据结构/8.7置换选择排序.png" width=80%></p>
<p>最佳归并树</p>
<p><img src="../img/数据结构/8.7最佳归并树_1.png" width=80%></p>
<p>二路归并和多路归并原理相同，都是构造哈夫曼树；对于 k 叉归并，如果初始归并段数量无法严格构成 k 叉归并树，需要补充长度为 0 的 "虚段" </p>
<p><img src="../img/数据结构/8.7最佳归并树_2.png" width=80%></p>
<h2 id="_2">总结<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="_3">串<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>next[i] 的值和 模式串中 i 前的子串的最大相同前后缀长度 k 决定，如果串索引由1开始，就是 k+1，否则就是 k；</p>
</li>
<li>
<p>计算 next 的过程可以理解为 模式串自己匹配自己的过程</p>
</li>
</ul>
<h3 id="_4">树<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<ul>
<li>哈夫曼树可以得到一种前缀编码，且带权路径长度是最小的（WPL）;且哈夫曼树无度为1的结点，<span class="arithmatex">\(n_0=n_2+1\)</span> 会很有用</li>
<li>并查集是一种简单的集合表示，find 如果不做路径压缩复杂度为 <span class="arithmatex">\(O(n)\)</span> </li>
<li>二叉排序树和平衡二叉树</li>
<li>红黑树的定义，插入和删除</li>
</ul>
<h3 id="_5">图<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>topological order：拓扑序，topological sequence：拓扑序列</p>
<p>基本概念</p>
<p>判断有向图是否有环：dfs，拓扑排序，求关键路径</p>
<h3 id="_6">查找<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>B 树 和 B+ 树的区别（至多，至少）</p>
<p>B树中结点和关键字的区别</p>
<h3 id="_7">排序<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>直接插入排序 比 折半插入排序的比较次数多了</p>
</li>
<li>
<p>希尔排序的时间复杂度</p>
</li>
<li>
<p>堆排的初始化，插入，删除；要注意小元素下坠时要下坠多次</p>
</li>
<li>选择排序比较次数是固定的，归并排序比较次数的数量级是固定的</li>
<li>基数排序 LSD（最低位优先） 的意思是先从最低为开始排，而不是最低位的重要性最大</li>
<li>外部排序常用归并排序</li>
</ul>
<p>总的需要注意的点：</p>
<ul>
<li>稳定的排序：插入，冒泡，归并，基数</li>
<li>每个算法的时间空间复杂度</li>
<li>最好情况下实践复杂度可以到达线性：冒泡排序，直接插入</li>
<li>排序有多个条件是，先比较重要性小的，再用稳定的排序算法比较重要性大的</li>
</ul>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky"], "search": "../../assets/javascripts/workers/search.85cb4492.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.f758a944.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
      
    
  </body>
</html>