{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u4e00\u540d\u849f\u84bb\u7684\u5b66\u4e60\u7b14\u8bb0","title":"Home"},{"location":"#_1","text":"","title":"\u4e00\u540d\u849f\u84bb\u7684\u5b66\u4e60\u7b14\u8bb0"},{"location":"Markdown/","text":"Markdown \u4e00\u79cd\u65b9\u4fbf\u7b80\u5355\u7684\u6392\u7248\u8bed\u8a00 \u4e0d\u540c\u7684\u5e73\u53f0\u4f7f\u7528 Markdow \u89c4\u5219\u53ef\u80fd\u6709\u4e9b\u8bb8\u4e0d\u540c\uff0c\u6bd4\u5982\u6807\u9898 # \u540e\u9762\u53ef\u80fd\u4e0d\u9700\u8981\u52a0\u7a7a\u683c\uff0c\u672c\u6587\u4e3b\u8981\u57fa\u4e8e typora \u57fa\u672c\u8bed\u6cd5 \u6807\u9898 \u4e00\u7ea7\u6807\u9898 # + \u7a7a\u683c \u4e8c\u7ea7\u6807\u9898 ## + \u7a7a\u683c ...\u6700\u591a\u6709\u516d\u7ea7\u6807\u9898 # Markdown ## \u57fa\u672c\u8bed\u6cd5 \u5f15\u7528 > + \u7a7a\u683c \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u5f15\u7528\u53ef\u4ee5\u5d4c\u5957 \u4f8b\u5b50 \u5d4c\u5957 \u5f3a\u8c03 * \u548c _ \u90fd\u53ef\u4ee5\u8868\u793a\u5f3a\u8c03 \u4f7f\u7528\u65b9\u5f0f\uff1a\u5728\u9700\u8981\u5f3a\u8c03\u7684\u90e8\u5206\u7684\u5934\u548c\u5c3e\u90fd\u8981\u52a0 \u4e00\u4e2a * \u6216\u8005 _ \u8868\u793a \u503e\u659c \u4e24\u4e2a * \u6216\u8005 _ \u8868\u793a \u52a0\u7c97 \u4e09\u4e2a * \u6216\u8005 _ \u8868\u793a \u52a0\u7c97\uff0b\u503e\u659c `*` \u53ef\u4ee5\u7528\u4e8e\u5f3a\u8c03\u4e00\u4e9b\u5b57\u7b26\uff0c\u6548\u679c\u5982\u4e0b * \u5217\u8868 * + \u7a7a\u683c \u6216\u8005 + + \u7a7a\u683c \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u5728\u4e00\u4e2a\u5217\u8868\u4e0b\u6309 tab \u4f1a\u53d8\u6210\u4e8c\u7ea7\u5217\u8868 \u8fd9\u662f\u4e00\u7ea7\u5217\u8868 \u8fd9\u662f\u4e8c\u7ea7\u5217\u8868 \u4ee3\u7801\u5757 ``` + \u8bed\u8a00(\u6bd4\u5982C++) + \u56de\u8f66 #include<iostream> using namespace std; int main() { cout << \"hello, world.\" return 0; } \u5206\u5272\u7ebf \u4e09\u4e2a\u6216\u8005\u66f4\u591a\u7684 + \u6216 _ \u6216 - + \u56de\u8f66 \u6548\u679c\uff1a \u8d85\u94fe\u63a5\u4e0e\u56fe\u7247 \u884c\u5185\u5f0f \u683c\u5f0f\uff1a[\u540d\u5b57] \uff08URL\uff09 [\u767e\u5ea6](https://www.baidu.com/) \u6548\u679c\u5982\u4e0b\uff1a \u767e\u5ea6 \u53c2\u8003\u5f0f \u5728\u8981\u591a\u6b21\u4f7f\u7528\u540c\u4e00\u4e2a\u8d85\u94fe\u63a5\u65f6\u4f7f\u7528 \u683c\u5f0f\uff1a[\u7ed9\u7f51\u7ad9\u8d77\u7684\u540d\u5b57]\uff1aURL \uff08\u76f8\u5f53\u4e8e\u5b9a\u4e49\uff09 \u4f7f\u7528\u65b9\u5f0f\uff1a[\u8d85\u94fe\u63a5\u7684\u540d\u5b57] [\u7ed9\u7f51\u7ad9\u8d77\u7684\u540d\u5b57] [\u767e\u5ea6]:https://www.baidu.com/ [here][\u767e\u5ea6] \u56fe\u7247 \u4e5f\u6709\u884c\u5185\u5f0f\u4e0e\u53c2\u8003\u5f0f\uff0c\u53ea\u662f\u5728\u524d\u9762\u52a0\u4e2a ! ![\u56fe\u7247\u540d][\u5177\u4f53\u5730\u5740\uff0c\u672c\u5730\u6216\u8005\u7f51\u9875] \u6570\u5b66\u516c\u5f0f 1.\u5185\u8054\u5f0f typora\u4e2d \u6587\u4ef6-\u504f\u597d\u8bbe\u7f6e-markdown-\u6253\u5f00\u5185\u8054\u516c\u5f0f $\u516c\u5f0f\u5185\u5bb9$ 2.\u975e\u5185\u8054\u5f0f \u6dfb\u52a0\u6570\u5b66\u516c\u5f0f\uff1a $$ + \u56de\u8f66 $$ \u516c\u5f0f\u5185\u5bb9 $$ \u5e38\u7528\u7b26\u53f7 \u7b26\u53f7 \u6548\u679c \u8868\u793a\u65b9\u5f0f \u4e0a\u4e0b\u6807 \\(x^2\\) x^2 x_2 \u5206\u5f0f \\(\\frac{1}{2}\\) \\frac{1}{2} \u6839\u53f7 \\(\\sqrt{2}\\) \\sqrt{2} \u77e2\u91cf \\(\\vec{a}\\) \\vec{a} \u4e0d\u5b9a\u79ef\u5206 \\(\\int{x}dx\\) \\int{x}dx \u5b9a\u79ef\u5206 \\(\\int_{1}^{2}{x}dx\\) \\int_{1}^{2}{x}dx \u7a7a\u683c \\quad \u6781\u9650 \\(\\lim{a+b}\\) \\lim{a+b} \\(\\lim_{n\\rightarrow+\\infty}\\) \\lim_{n\\rightarrow+\\infty} \\(\\lim_{n\\rightarrow+\\infty}{a+b}\\) \\lim_{n\\rightarrow+\\infty}{a+b} \u7d2f\u52a0 \\(\\sum{a}\\) \\sum{a} \\(\\sum_{i=1}^{n}{a_i}\\) \\sum_{i=1}^{n}{a_i} \u7d2f\u4e58 \\(\\prod{x}\\) \\prod{x} \\(\\prod_{i=1}^{n}{x_i}\\) \\prod_{i=1}^{n}{x_i} \u5bf9\u6570\u51fd\u6570 \\(\\ln2\\) \\ln2 \\(\\log_{11}{121}\\) \\log_{11}{121} \\(\\lg10\\) \\lg10 \u52a0\u51cf \\(\\pm\\) \\pm \u53c9\u4e58 \\(\\times\\) \\times \u70b9\u4e58 \\(\\cdot\\) \\cdot \u9664\u6cd5 \\(\u00f7\\) \\div \u4e0d\u7b49 \\(\\neq\\) \\neq \u6052\u7b49 \\(\\equiv\\) \\equiv \u5c0f\u4e8e\u7b49\u4e8e \\(\\leq\\) \\leq \u5927\u4e8e\u7b49\u4e8e \\(\\geq\\) \\geq \u7ea6\u7b49\u4e8e \\(\\approx\\) \\approx \u56e0\u4e3a \\(\\because\\) \\because \u6240\u4ee5 \\(\\therefore\\) \\therefore \u5408\u53d6 \\(\\wedge\\) \\wedge \u6790\u53d6 \\(\\vee\\) \\vee \u8574\u542b \\(\\Rightarrow\\) \\Rightarrow \u975e \\(\\urcorner\\) \\urcorner \u5927\u62ec\u53f7 \\[ y = \\begin{cases} 1\uff0cx \\geq 0 \\\\ 0, x < 0 \\end{cases} \\] y = \\begin{cases} 1\uff0cx \\geq 0 \\\\ 0, x < 0 \\end{cases} \u77e9\u9635 $$ \\begin{bmatrix} a & b \\ c & d \\end{bmatrix} $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \u8868\u683c\u5143\u7d20 typora \u4e2d\u4f7f\u7528\u5feb\u6377\u952e Ctrl+T name|score ----|---- abcd|100 defg|0 name score abcd 100 defg 0 \u6298\u53e0\u4ee3\u7801\u548c\u4fa7\u8fb9\u680f typora\u4e2d\u6298\u53e0\u4fa7\u8fb9\u680f\uff1a\u6587\u4ef6-\u504f\u597d\u8bbe\u7f6e-\u5916\u89c2-\u4fa7\u8fb9\u680f \u6298\u53e0\u4ee3\u7801\uff1a <details> <summary>tag</summary> <code> Hello world! </code> </details> \u6548\u679c\u5982\u4e0b\uff1a tag Hello world! \u5bfc\u51fa\u5176\u4ed6\u683c\u5f0f typora \u4e2d\u53ef\u4ee5\u76f4\u63a5\u70b9\u51fb \u6587\u4ef6-\u5bfc\u51fa \u5e76\u9009\u62e9\u6587\u4ef6\u683c\u5f0f\u5373\u53ef \u5bfc\u51fa\u4e3a word \u4e4b\u524d\u9700\u8981\u4e0b\u8f7dpandoc\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u7f51\u4e0a\u535a\u5ba2 \u53c2\u8003 Introduction | Learning-Markdown (Markdown \u5165\u95e8\u53c2\u8003) (xianbai.me) Supported Functions \u00b7 KaTeX","title":"Makrdown"},{"location":"Markdown/#markdown","text":"\u4e00\u79cd\u65b9\u4fbf\u7b80\u5355\u7684\u6392\u7248\u8bed\u8a00 \u4e0d\u540c\u7684\u5e73\u53f0\u4f7f\u7528 Markdow \u89c4\u5219\u53ef\u80fd\u6709\u4e9b\u8bb8\u4e0d\u540c\uff0c\u6bd4\u5982\u6807\u9898 # \u540e\u9762\u53ef\u80fd\u4e0d\u9700\u8981\u52a0\u7a7a\u683c\uff0c\u672c\u6587\u4e3b\u8981\u57fa\u4e8e typora","title":"Markdown"},{"location":"Markdown/#_1","text":"","title":"\u57fa\u672c\u8bed\u6cd5"},{"location":"Markdown/#_2","text":"\u4e00\u7ea7\u6807\u9898 # + \u7a7a\u683c \u4e8c\u7ea7\u6807\u9898 ## + \u7a7a\u683c ...\u6700\u591a\u6709\u516d\u7ea7\u6807\u9898 # Markdown ## \u57fa\u672c\u8bed\u6cd5","title":"\u6807\u9898"},{"location":"Markdown/#_3","text":"> + \u7a7a\u683c \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u5f15\u7528\u53ef\u4ee5\u5d4c\u5957 \u4f8b\u5b50 \u5d4c\u5957","title":"\u5f15\u7528"},{"location":"Markdown/#_4","text":"* \u548c _ \u90fd\u53ef\u4ee5\u8868\u793a\u5f3a\u8c03 \u4f7f\u7528\u65b9\u5f0f\uff1a\u5728\u9700\u8981\u5f3a\u8c03\u7684\u90e8\u5206\u7684\u5934\u548c\u5c3e\u90fd\u8981\u52a0 \u4e00\u4e2a * \u6216\u8005 _ \u8868\u793a \u503e\u659c \u4e24\u4e2a * \u6216\u8005 _ \u8868\u793a \u52a0\u7c97 \u4e09\u4e2a * \u6216\u8005 _ \u8868\u793a \u52a0\u7c97\uff0b\u503e\u659c `*` \u53ef\u4ee5\u7528\u4e8e\u5f3a\u8c03\u4e00\u4e9b\u5b57\u7b26\uff0c\u6548\u679c\u5982\u4e0b *","title":"\u5f3a\u8c03"},{"location":"Markdown/#_5","text":"* + \u7a7a\u683c \u6216\u8005 + + \u7a7a\u683c \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u8fd9\u662f\u4e00\u4e2a\u4f8b\u5b50 \u5728\u4e00\u4e2a\u5217\u8868\u4e0b\u6309 tab \u4f1a\u53d8\u6210\u4e8c\u7ea7\u5217\u8868 \u8fd9\u662f\u4e00\u7ea7\u5217\u8868 \u8fd9\u662f\u4e8c\u7ea7\u5217\u8868","title":"\u5217\u8868"},{"location":"Markdown/#_6","text":"``` + \u8bed\u8a00(\u6bd4\u5982C++) + \u56de\u8f66 #include<iostream> using namespace std; int main() { cout << \"hello, world.\" return 0; }","title":"\u4ee3\u7801\u5757"},{"location":"Markdown/#_7","text":"\u4e09\u4e2a\u6216\u8005\u66f4\u591a\u7684 + \u6216 _ \u6216 - + \u56de\u8f66 \u6548\u679c\uff1a","title":"\u5206\u5272\u7ebf"},{"location":"Markdown/#_8","text":"\u884c\u5185\u5f0f \u683c\u5f0f\uff1a[\u540d\u5b57] \uff08URL\uff09 [\u767e\u5ea6](https://www.baidu.com/) \u6548\u679c\u5982\u4e0b\uff1a \u767e\u5ea6 \u53c2\u8003\u5f0f \u5728\u8981\u591a\u6b21\u4f7f\u7528\u540c\u4e00\u4e2a\u8d85\u94fe\u63a5\u65f6\u4f7f\u7528 \u683c\u5f0f\uff1a[\u7ed9\u7f51\u7ad9\u8d77\u7684\u540d\u5b57]\uff1aURL \uff08\u76f8\u5f53\u4e8e\u5b9a\u4e49\uff09 \u4f7f\u7528\u65b9\u5f0f\uff1a[\u8d85\u94fe\u63a5\u7684\u540d\u5b57] [\u7ed9\u7f51\u7ad9\u8d77\u7684\u540d\u5b57] [\u767e\u5ea6]:https://www.baidu.com/ [here][\u767e\u5ea6] \u56fe\u7247 \u4e5f\u6709\u884c\u5185\u5f0f\u4e0e\u53c2\u8003\u5f0f\uff0c\u53ea\u662f\u5728\u524d\u9762\u52a0\u4e2a ! ![\u56fe\u7247\u540d][\u5177\u4f53\u5730\u5740\uff0c\u672c\u5730\u6216\u8005\u7f51\u9875]","title":"\u8d85\u94fe\u63a5\u4e0e\u56fe\u7247"},{"location":"Markdown/#_9","text":"1.\u5185\u8054\u5f0f typora\u4e2d \u6587\u4ef6-\u504f\u597d\u8bbe\u7f6e-markdown-\u6253\u5f00\u5185\u8054\u516c\u5f0f $\u516c\u5f0f\u5185\u5bb9$ 2.\u975e\u5185\u8054\u5f0f \u6dfb\u52a0\u6570\u5b66\u516c\u5f0f\uff1a $$ + \u56de\u8f66 $$ \u516c\u5f0f\u5185\u5bb9 $$ \u5e38\u7528\u7b26\u53f7 \u7b26\u53f7 \u6548\u679c \u8868\u793a\u65b9\u5f0f \u4e0a\u4e0b\u6807 \\(x^2\\) x^2 x_2 \u5206\u5f0f \\(\\frac{1}{2}\\) \\frac{1}{2} \u6839\u53f7 \\(\\sqrt{2}\\) \\sqrt{2} \u77e2\u91cf \\(\\vec{a}\\) \\vec{a} \u4e0d\u5b9a\u79ef\u5206 \\(\\int{x}dx\\) \\int{x}dx \u5b9a\u79ef\u5206 \\(\\int_{1}^{2}{x}dx\\) \\int_{1}^{2}{x}dx \u7a7a\u683c \\quad \u6781\u9650 \\(\\lim{a+b}\\) \\lim{a+b} \\(\\lim_{n\\rightarrow+\\infty}\\) \\lim_{n\\rightarrow+\\infty} \\(\\lim_{n\\rightarrow+\\infty}{a+b}\\) \\lim_{n\\rightarrow+\\infty}{a+b} \u7d2f\u52a0 \\(\\sum{a}\\) \\sum{a} \\(\\sum_{i=1}^{n}{a_i}\\) \\sum_{i=1}^{n}{a_i} \u7d2f\u4e58 \\(\\prod{x}\\) \\prod{x} \\(\\prod_{i=1}^{n}{x_i}\\) \\prod_{i=1}^{n}{x_i} \u5bf9\u6570\u51fd\u6570 \\(\\ln2\\) \\ln2 \\(\\log_{11}{121}\\) \\log_{11}{121} \\(\\lg10\\) \\lg10 \u52a0\u51cf \\(\\pm\\) \\pm \u53c9\u4e58 \\(\\times\\) \\times \u70b9\u4e58 \\(\\cdot\\) \\cdot \u9664\u6cd5 \\(\u00f7\\) \\div \u4e0d\u7b49 \\(\\neq\\) \\neq \u6052\u7b49 \\(\\equiv\\) \\equiv \u5c0f\u4e8e\u7b49\u4e8e \\(\\leq\\) \\leq \u5927\u4e8e\u7b49\u4e8e \\(\\geq\\) \\geq \u7ea6\u7b49\u4e8e \\(\\approx\\) \\approx \u56e0\u4e3a \\(\\because\\) \\because \u6240\u4ee5 \\(\\therefore\\) \\therefore \u5408\u53d6 \\(\\wedge\\) \\wedge \u6790\u53d6 \\(\\vee\\) \\vee \u8574\u542b \\(\\Rightarrow\\) \\Rightarrow \u975e \\(\\urcorner\\) \\urcorner \u5927\u62ec\u53f7 \\[ y = \\begin{cases} 1\uff0cx \\geq 0 \\\\ 0, x < 0 \\end{cases} \\] y = \\begin{cases} 1\uff0cx \\geq 0 \\\\ 0, x < 0 \\end{cases} \u77e9\u9635 $$ \\begin{bmatrix} a & b \\ c & d \\end{bmatrix} $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}","title":"\u6570\u5b66\u516c\u5f0f"},{"location":"Markdown/#_10","text":"typora \u4e2d\u4f7f\u7528\u5feb\u6377\u952e Ctrl+T name|score ----|---- abcd|100 defg|0 name score abcd 100 defg 0","title":"\u8868\u683c\u5143\u7d20"},{"location":"Markdown/#_11","text":"typora\u4e2d\u6298\u53e0\u4fa7\u8fb9\u680f\uff1a\u6587\u4ef6-\u504f\u597d\u8bbe\u7f6e-\u5916\u89c2-\u4fa7\u8fb9\u680f \u6298\u53e0\u4ee3\u7801\uff1a <details> <summary>tag</summary> <code> Hello world! </code> </details> \u6548\u679c\u5982\u4e0b\uff1a tag Hello world!","title":"\u6298\u53e0\u4ee3\u7801\u548c\u4fa7\u8fb9\u680f"},{"location":"Markdown/#_12","text":"typora \u4e2d\u53ef\u4ee5\u76f4\u63a5\u70b9\u51fb \u6587\u4ef6-\u5bfc\u51fa \u5e76\u9009\u62e9\u6587\u4ef6\u683c\u5f0f\u5373\u53ef \u5bfc\u51fa\u4e3a word \u4e4b\u524d\u9700\u8981\u4e0b\u8f7dpandoc\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u7f51\u4e0a\u535a\u5ba2","title":"\u5bfc\u51fa\u5176\u4ed6\u683c\u5f0f"},{"location":"Markdown/#_13","text":"Introduction | Learning-Markdown (Markdown \u5165\u95e8\u53c2\u8003) (xianbai.me) Supported Functions \u00b7 KaTeX","title":"\u53c2\u8003"},{"location":"OI/%E5%85%B6%E4%BB%96/","text":"6 \u5176\u4ed6 6.1 \u535a\u5f08\u8bba 6.1.1 NIM \u5fc5\u80dc\u6001\uff1a \\( \\(a_1XORa_2XOR\\dots XORa_n \\neq 0\\) \\) \u5fc5\u8d25\u6001\uff1a \\( \\(a_1XORa_2XOR\\dots XORa_n = 0\\) \\) \u5176\u4ed6\uff1a Staircase Nim\uff1aPOJ 1704 6.1.2 Grundy\u503c void grundy() { grundy[0] = 0; //\u5fc5\u8d25\uff0c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u4e0d\u5199\u8ba9j\u4ece0\u5f00\u59cb int maxa = *max_element(a, a+n); for(int j = 1; j <= maxa; j++) { set<int> s; for(int i = 0; i < k; i++) if(a[i] <= j) s.insert(grundy(j-a[i])); int g = 0; while(s.count(g) != 0) g++; grundy[j] = g; } } 6.2 \u79bb\u6563\u5316 //\u767d\u4e66P164\uff0c\u4e8c\u7ef4\u5750\u6807\u79bb\u6563\u5316 typedef long long ll; const int maxn = 600; int x1[maxn], x2[maxn], y1[maxn], y2[maxn]; int n; int compress(int *x1, int *x2, int w) { vector<int> vec; for (int i = 0; i < n; i++) { for (int d = -1; d <= 1; d++) { int tx1 = x1[i] + d, tx2 = x2[i] + d; if (tx1 >= 1 && tx1 <= w) vec.push_back(tx1); if (tx2 >= 1 && tx2 <= w) vec.push_back(tx2); } } sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); for (int i = 0; i < n; i++) { x1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin(); x2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin(); } return vec.size(); }","title":"\u5176\u4ed6"},{"location":"OI/%E5%85%B6%E4%BB%96/#6","text":"","title":"6 \u5176\u4ed6"},{"location":"OI/%E5%85%B6%E4%BB%96/#61","text":"","title":"6.1 \u535a\u5f08\u8bba"},{"location":"OI/%E5%85%B6%E4%BB%96/#611-nim","text":"\u5fc5\u80dc\u6001\uff1a \\( \\(a_1XORa_2XOR\\dots XORa_n \\neq 0\\) \\) \u5fc5\u8d25\u6001\uff1a \\( \\(a_1XORa_2XOR\\dots XORa_n = 0\\) \\) \u5176\u4ed6\uff1a Staircase Nim\uff1aPOJ 1704","title":"6.1.1 NIM"},{"location":"OI/%E5%85%B6%E4%BB%96/#612-grundy","text":"void grundy() { grundy[0] = 0; //\u5fc5\u8d25\uff0c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u4e0d\u5199\u8ba9j\u4ece0\u5f00\u59cb int maxa = *max_element(a, a+n); for(int j = 1; j <= maxa; j++) { set<int> s; for(int i = 0; i < k; i++) if(a[i] <= j) s.insert(grundy(j-a[i])); int g = 0; while(s.count(g) != 0) g++; grundy[j] = g; } }","title":"6.1.2 Grundy\u503c"},{"location":"OI/%E5%85%B6%E4%BB%96/#62","text":"//\u767d\u4e66P164\uff0c\u4e8c\u7ef4\u5750\u6807\u79bb\u6563\u5316 typedef long long ll; const int maxn = 600; int x1[maxn], x2[maxn], y1[maxn], y2[maxn]; int n; int compress(int *x1, int *x2, int w) { vector<int> vec; for (int i = 0; i < n; i++) { for (int d = -1; d <= 1; d++) { int tx1 = x1[i] + d, tx2 = x2[i] + d; if (tx1 >= 1 && tx1 <= w) vec.push_back(tx1); if (tx2 >= 1 && tx2 <= w) vec.push_back(tx2); } } sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); for (int i = 0; i < n; i++) { x1[i] = find(vec.begin(), vec.end(), x1[i]) - vec.begin(); x2[i] = find(vec.begin(), vec.end(), x2[i]) - vec.begin(); } return vec.size(); }","title":"6.2 \u79bb\u6563\u5316"},{"location":"OI/%E5%9B%BE%E8%AE%BA/","text":"3 \u56fe\u8bba 3.1 \u56fe\u7684\u5b58\u50a8 3.1.1 \u90bb\u63a5\u77e9\u9635 \u7565 3.1.2 \u90bb\u63a5\u8868 vector<int> es[MAXN]; /* \u5e26\u6743\u8fb9 struct edge{ int to, w; }; vector<edge> es[MAXN]; */ 3.1.3 \u94fe\u5f0f\u524d\u5411\u661f struct edge { int to, w, next; }es[MAX_E]; int cnt = 0; void init(){ memset(head, -1, sizeof head); } void add_edge(int u, int v, int w){ //\u52a0\u8fb9 es[cnt].to = v; es[cnt].w = w; es[cnt].next = head[u]; head[u] = cnt++; } /*\u904d\u5386 for(int i = 1; i <= n; i++) for(int j = head[i]; i != -1; j = es[j].next) /*...*/ */ 3.2 \u6700\u77ed\u8def Bellman-Ford \u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \\(O(VE)\\) \u652f\u6301\u8d1f\u6743 struct edge{ int from, to, w; }; edge es[MAX_E]; int d[MAX_V]; int V, E; void BF(int s){ memset(d, INF, sizeof d); d[s] = 0; for(int k = 0; k < V; k++){ for(int i = 0; i < E; i++){ edge e = es[i]; if(d[e.from] != INF && d[e.to] > d[e.from]+e.w){ d[e.to] = d[e.from]+w; //\u677e\u5f1b\u64cd\u4f5c } } } } //\u5faa\u73af\u81f3\u591a\u6267\u884c V-1 \u6b21\uff0c\u4e00\u6b21\u677e\u5f1b\u64cd\u4f5c\u81f3\u5c11\u8ba9\u786e\u5b9a\u7684\u6700\u77ed\u8def+1\uff0c\u6240\u4ee5O(VE)\uff0c\u5982\u679c\u7b2c n \u6b21\u4efb\u7136\u66f4\u65b0\u4e86d\uff0c\u8868\u793a\u6709\u8d1f\u73af //\u628a\u6240\u6709d[i]\u521d\u59cb\u5316\u4e3a0\uff0c\u5c31\u53ef\u4ee5\u627e\u5230\u6240\u6709\u7684\u8d1f\u5708 bool find_negative_loop(){ memset(d, 0, sizeof d); for(int i = 0; i < V; i++){ for(int j = 0; j < E; j++){ edge e = es[j]; if(d[e.to] > d[e.from]+e.w){ d[e.to] = d[e.from]+e.w; if(i == V-1) return true; } } } return false; } Dijkstra \u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \u4e0d\u652f\u6301\u8d1f\u6743\u8fb9 \u68c0\u67e5\u5b58\u5728 \\(d[i][i]\\) \u4e3a\u8d1f\u6570\u6765\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af \\(O(ElogV)\\) \u7528\u4f18\u5148\u961f\u5217 typedef pair<int, int> P; vector<P> es[MAX_V]; //\u90bb\u63a5\u8868\u4e2dfirst\u8868\u793a\u7aef\u70b9\uff0csecond\u8868\u793a\u6743\u503c int d[MAX_V]; void dijkstra(int s) { priority_queue< P, vector<P>, greater<P> > que; //\u961f\u5217\u4e2dfirst\u8868\u793a\u6700\u77ed\u8def\uff0c second\u8868\u793a\u7aef\u70b9 memset(d, INF, sizeof d); d[s] = 0; que.push(P(0, s)); while(!que.empty()) { P p = que.top(); que.pop(); int u = p.second; if(d[u] < p.first) continue; for(int i = 0; i < es[u].size(); i++) { int v = es[u][i].first, w = es[u][i].second; if(d[v] > d[u]+w) //\u677e\u5f1b\u64cd\u4f5c { d[v] = d[u]+w; que.push(P(d[v], v)); } } } } \u94fe\u5f0f\u524d\u5411\u661f\u7684\u7248\u672c struct edge { int to, w, next; }edge[max_e]; struct node{ int to, w; bool operator < (const node& a) const{ return w > a.w; } }; int d[max_v], head[max_v], visited[max_v], n, m, cnt = 0; void init(){ memset(head, -1, sizeof head); } void add_edge(int u, int v, int w){ edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; } void dijkstra(int s){ priority_queue<node> que; fill(d, d+n+1, inf); memset(visited, false, sizeof visited); d[s] = 0; node tmp; tmp.to = s, tmp.w = 0; que.push(tmp); while(!que.empty()){ node t = que.top(); que.pop(); if(visited[t.to]) continue; visited[t.to] = true; for(int i = head[t.to]; i != -1; i = edge[i].next){ int v = edge[i].to; if(!visited[v] && d[v] > d[t.to]+edge[i].w){ d[v] = d[t.to]+edge[i].w; tmp.to = v, tmp.w = d[v]; que.push(tmp); } } } } int main(){ init(); scanf(\"%d %d\", &n, &m); int a, b, c; for(int i = 0; i < m; i++){ scanf(\"%d %d %d\", &a, &b, &c); add_edge(a, b, c); } dijkstra(1); printf(\"%d\\n\", d[n]); return 0; } Floyd-Warshall \\(O(V^3)\\) dp:\u72b6\u6001\u8f6c\u79fb\u65b9\u65b9\u7a0b \\(d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][i])\\) , \u5373 \\(d[i][j] = min(dp[i][k], dp[k][j])\\) int d[MAX_V[MAX_V]; void floyd() { for(int k = 0; k < V; k++) for(int i = 0; i < V; i++) for(int j = 0; j < V; j++) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); } \u8def\u5f84\u8fd8\u539f \u5728\u677e\u5f1b\u64cd\u4f5c\u65f6\u8bb0\u5f55\u6bcf\u4e2a\u7ed3\u70b9\u7684\u524d\u8d8b\u7ed3\u70b9 \\(path[i]\\) \u5373\u53ef, \u67e5\u8be2\u65f6\u4ece\u540e\u5f80\u524d\u904d\u5386 \u6b21\u77ed\u8def //\u6bcf\u6b21\u66f4\u65b0\u6700\u77ed\u8def\u65f6\u770b\u770b\u88ab\u629b\u5f03\u7684\u503c\u80fd\u4e0d\u80fd\u66f4\u65b0\u6b21\u77ed\u8def typedef pair<int, int> P; const int inf = 0x3f3f3f3f; vector<P> es[max_v]; int n, r, a, b, c; int d1[max_v], d2[max_v]; //d2 \u6b21\u77ed\u8def void dijkstra(int s){ memset(d1, inf, sizeof d1); memset(d2, inf, sizeof d2); priority_queue< P, vector<P>, greater<P> > que; d1[s] = 0; que.push(P(0, s)); while(!que.empty()){ P p = que.top(); que.pop(); int u = p.second; if(d2[u] < p.first) continue; for(int i = 0; i < es[u].size(); i++){ int v = es[u][i].first, w = es[u][i].second; int tmp = p.first+w; if(d1[v] > tmp){ swap(tmp, d1[v]); que.push(P(d1[v], v)); } if(tmp < d2[v] && tmp > d1[v]){ d2[v] = tmp; que.push(P(d2[v], v)); } } } } 3.3 \u6700\u5c0f\u751f\u6210\u6811 \u524d\u63d0\uff1a\u56fe\u662f\u8fde\u901a\u7684 Prim \\(O(V^2)\\) vector<edge> es[max_v]; int dis[MAX_V]; bool vis[MAX_V]; int prime(){ memset(dis, inf, sizeof dis); memset(vis, false, vis); dis[0] = 0; //s int res = 0; while(true){ int v = -1, mn = inf; for(int i = 0; i < V; i++) if(!visited[i] && dis[i] < mn) mn = dis[i], v = i; if(v == -1) break; vis[v] = true; res += mn; for(int i = 0; i < es[v].size(); i++){ edge e = es[v][i]; dis[e.to] = min(dis[e.to], e.w); } } return res; } Kruskal \u6309\u7167\u8fb9\u7684\u6743\u503c\u4ece\u5c0f\u5230\u8fbe\uff0c\u5229\u7528\u5e76\u67e5\u96c6\u5224\u65ad\u662f\u5426\u4f1a\u4ea7\u51fa\u5708\uff0c\u4e0d\u4f1a\u5c31\u52a0\u5165 \\(O(ElogV)\\) struct edge{ int from, to, w; }; edge es[MAX_E]; bool cmp(edge a, edge b){ return a.w < b.w; } int kruskal(){ sort(es, es+E, cmp); init(MAX_V); //\u5e76\u67e5\u96c6\u7684\u521d\u59cb\u5316 int res = 0; for(int i = 0; i < E; i++){ edge e = es[i]; if(!same(e.from, e.to)){ unite(e.from, e.to); res += e.w; } } return res; } 3.4 \u7f51\u7edc\u6d41 \u6700\u5927\u6d41 Dinic struct edge{ int to, cap, rev; } //rev\u8bb0\u5f55\u53cd\u5411\u8fb9\u5728 es[to] \u4e2d\u7684\u7d22\u5f15 vector<edge> es[max_v]; //\u90bb\u63a5\u8868 int level[max_v]; //\u5206\u5c42\u56fe int iter[max_v]; //\u5f27\u4f18\u5316\uff0c\u8bb0\u5f55\u7ed3\u70b9\u589e\u5e7f\u8fc7\u54ea\u4e9b\u8fb9\u4e86\uff0c\u4e0b\u6b21\u5c31\u4e0d\u589e\u5e7f\u4e86 void add_edge(int from, int to, int cap) {//\u52a0\u8fb9 es[from].push_back(edge{to, cap, es[to].size()}); es[to].push_back(edge{from, 0, es[from].size()-1}); } void bfs(int s) {//\u5206\u5c42\u56fe memset(level, -1, sizeof level); queue<int> que; level[s] = 0; que.push(s); while(!que.empty()){ int v = que.front(), que.pop(); for(int i = 0; i < es[i].size(); i++){ edge &e = es[v][i]; if(e.cap > 0 && level[e.to] < 0){ level[e.to] = level[v]+1; que.push(e.to); } } } } int dfs(int cur, int t, int f) { //\u589e\u5e7f\u8def if(cur == t) return f; for(int &i = iter[cur]; i < es[cur].size(); i++){ edge &e = es[cur][i]; if(e.cap > 0 && level[cur] < level[e.to]){ int d = dfs(e.to, t, min(f, e.cap)); if(d > 0) { e.cap -= d; es[e.to][e.rev].cap += d; return d; } } } return 0; } int max_flow(int s, int t){ int flow = 0; while(1){ bfs(s); if(level[t] < 0) return flow; memset(iter, 0, sizeof iter); int f; while(f = dfs(s, t, inf) > 0) flow += f; } } \u6700\u5c0f\u8d39\u7528\u6d41 \u8d1f\u6743\u8fb9\uff0c\u7528 BF \u7b97\u6cd5 const int inf = 0x3f3f3f3f; struct edge{int to, cap, cost, rev; } vector<edge> es[max_v]; int dist[max_v]; int pree[max_e], prev[max_v]; //\u524d\u5bfc\u9876\u70b9\u7684\u5bf9\u5e94\u7684\u8fb9\u7684\u7d22\u5f15 void add_edge(int from, int to, int cap, int cost){ es[from].push_back(edge{to, cap, cost, es[to].size()}); es[to].push_back(edge{from, 0, -cost, es[from].size()-1}); } int min_cost_flow(int s, int t, int f) { //\u8d77\u70b9 \u7ec8\u70b9 \u6d41\u91cf int res = 0; while(f > 0){ memset(dist, inf, sizeof dist); dist[s] = 0; while(true) bool update = false; for(int i = 0; i < V; i++) { if(dist[i] == inf) continue; for(int j = 0; j < es[i].size(); j++) { edge &e = es[i][j]; if(e.cap > 0 && dist[e.to] > dist[e.from]+e.cost) { dist[to] = dist[from]+e.cost; prev[e.to] = i; pree[e.to] = j; update = true; } } } if(!update) break; } if(dist[t] == inf) return -1; //\u6cbfs\u5230t\u7684\u6700\u77ed\u8def\u5c3d\u91cf\u589e\u5e7f int d = f; for(int i = t; i != s; i = prev[i]) d = min(d, es[prev[i]][pree[i]].cap); f -= d; res += d*dist[t]; for(int i = t; i != s; i = prev[i]) { edge &e = es[prev[i][pree[i]]]; e.cap -= d; es[i][e.rev].cap += d; } } return res; } 3.5 \u4e8c\u5206\u56fe\u5339\u914d 3.5.1 \u6700\u5927\u6d41 \u6dfb\u52a0\u539f\u70b9\u548c\u6c47\u70b9\uff0c\u8ba1\u7b97\u6700\u5927\u6d41 //\u8ba1\u7b97\u673a\u5904\u7406\u4efb\u52a1 bool can[max_n][max_m]; // can[i][j] : \u8ba1\u7b97\u673a i \u80fd\u5904\u7406\u4efb\u52a1 j void MaxMatch(){ //\u8ba1\u7b97\u673a\u5bf9\u5e94\u7684\u9876\u70b9\uff1a0 ~ n-1 //\u4efb\u52a1\u5bf9\u5e94\u7684\u9876\u70b9\uff1an ~ n+m-1 int s = n+m, t = n+m+1; for(int i = 0; i < n; i++){ add_edge(s, i, 1); } for(int i = 0; i < m; i++){ add_edge(n+i, t, 1); } for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) add_edge(i, n+j, 1); cout << max_flow(s, t) << endl; } 3.5.2 \u5308\u7259\u5229\u7b97\u6cd5 \\(O(VE)\\) bool vis[max_v]; int match[max_v]; vector<int> es[max_v]; void add_edge(int u, int v){ es[u].push_back(v); es[v].push_back(u); } bool dfs(int cur){ for(int i = 0; i < es[cur].size(); i++){ int v = es[cur][i]; if(vis[v]) continue; vis[v] = true; if(!match[v] || dfs(match[v])){ match[v] = cur; match[cur] = v; return true; } } return false; } int MaxMatch(){ int res = 0; for(int i = 1; i <= n; i++){ //\u5bfb\u627e\u589e\u5e7f\u8def\u5f84 memset(vis, 0, sizeof vis); if(!match[i] && dfs(i)) res++; } return res; } 3.5.3 Hopcroft-Karp \\(O(E\\sqrt{V})\\) HDU 2389 int match[max_v], dep[max_v]; vector<int> es[max_v]; bool bfs() { memset(dep, 0, sizeof dep); queue<int> q; for (int i = 1; i <= n; i++) if (!match[i]) q.push(i); bool flag = false; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i < es[u].size(); i++) { int v = es[u][i]; if (dep[v]) continue; dep[v] = dep[u] + 1; if (!match[v]) flag = true; else dep[match[v]] = dep[v] + 1, q.push(match[v]); } } return flag; } bool dfs(int u) { for (int i = 0; i < es[u].size(); i++) { int v = es[u][i]; if (dep[v] != dep[u] + 1) continue; dep[v] = 0; if (!match[v] || dfs(match[v])) { match[v] = u; match[u] = v; return true; } } return false; } int MaxMatch() { int res = 0; while (bfs()) { for (int i = 1; i <= n; i++) if (!match[i] && dfs(i)) res++; } return res; } 3.6 \u8fde\u901a\u6027\u76f8\u5173 3.6.1 \u5f3a\u8fde\u901a\u5206\u91cf\u5206\u89e3 \\[O(V+E)\\] \u4e24\u6b21DFS\uff0c\u7b2c\u4e00\u904d\u540e\u5e8f\u904d\u5386\u5e76\u7ed9\u9876\u70b9\u6807\u53f7\uff0c\u7b2c\u4e8c\u904d\u5bf9\u53cd\u5411\u56fe\u904d\u5386 vector<int> G[max_v]; vector<int> rG[max_v]; //\u53cd\u5411\u56fe vector<int> vs; //vertex sequence bool vis[max_v]; int cmp[max_v]; //\u6240\u5c5e\u5f3a\u8fde\u901a\u56fe\u7684\u62d3\u6251\u5e8f void add_edge(int u, int v){ G[u].push_back(v); rG[v].push_back(u); } void dfs(int v){ vis[v] = true; for(int i = 0; i < G[v].size(); i++) if(!vis[G[v][i]]) dfs(G[v][i]); vs.push_back(v); } void rdfs(int v, int k){ vis[v] = true; cmp[v] = k; for(int i = 0; i < rG[v].size(); i++) if(!vis[rG[v][i]]) rdfs(rG[v][i], k); } int scc() { //strongly connected component memset(vis, false, sizeof vis); vs.clear(); for(int v = 0; v < V; v++) if(!vis[v]) dfs(v); memset(vis, false, sizeof vis); int k = 0; for(int i = vs.size()-1; i >= 0; i--) if(!vis[vs[i]]) rdfs(vs[i], k++); return k; } 3.6.2 \u8fde\u901a\u5206\u652f\u4e2a\u6570 \u5e76\u67e5\u96c6 3.7 \u6811\u4e0a\u95ee\u9898 3.7.1 \u6700\u8fd1\u516c\u5171\u7956\u5148(LCA) \\[O(n)\\] vector<int> G[maxn_v]; int root, parent[max_v], depth[max_v]; void dfs(int v, int p, int d){ parent[v] = p, depth[v] = d; for(int i = 0; i < G[v].size(); i++) if(G[v][i] != p) dfs(G[v][i], v, d+1); } void init(){ dfs(root, -1, 0); } int lca(int u, int v){ //\u5148\u628au,v\u8d70\u5230\u540c\u4e00\u6df1\u5ea6 while(depth[u] > depth[v]) u = parent[u]; while(depth[v] > depth[u]) v = parent[v]; //\u4e00\u8d77\u5411\u4e0a\u8d70 while(u != v){ u = parent[u], v = parent[v]; } return u; } \u57fa\u4e8e\u4e8c\u5206\u641c\u7d22\u7684\u7b97\u6cd5 \u5bf9\u4e8e\u4efb\u610f\u7ed3\u70b9v\uff0c\u53ef\u4ee5\u901a\u8fc7 parent2[v] = parent[parent[v]] parent4[v] = parent2[parent2[v]] ... \u5f97\u5230\u5176\u5411\u4e0a\u8d70 \\( \\(2^k\\) \\) \u6b65\u5230\u8fbe\u7684\u9876\u70b9 \u6bcf\u6b21\u641c\u7d22\u7684\u590d\u6742\u5ea6\uff1a \\( \\(O(logn)\\) \\) \uff0c\u9884\u5904\u7406\u7684\u590d\u6742\u5ea6\uff1a \\( \\(O(nlogn)\\) \\) vector<int> G[max_v]; int root, parent[max_k][max_v], depth[max_v]; void dfs(int v, int p, int d){ depth[v] = d, parent[v] = p; for(int i = 0; i < G[v].size(); i++) if(G[v][i] != p) dfs(G[v][i], v, d+1); } void init(int V){ //\u9884\u5904\u7406parent[0]\u548cdepth dfs(root, -1, 0); //\u9884\u5904\u7406parent for(int k = 0; k+1 < max_k; k++) for(int i = 0; i < V; i++) { //parent[k][v] \u8868\u793a\u4ece v \u7ed3\u70b9\u5411\u4e0a\u8d70 2^k \u6b21\u7684\u7ed3\u70b9\uff0c \u8d85\u8fc7\u6839\u65f6\u8bb0\u4f5c-1 if(parent[k][i] < 0) parent[k+1][i] = -1; else parent[k+1][i] = parent[k][parent[k][i]]; } } int lca(int u, int v){ //\u8ba9u\u548cv\u8d70\u5230\u540c\u4e00\u6df1\u5ea6 if(depth[u] > depth[v]) swap(u, v); //\u8ba9v\u7684\u6df1\u5ea6\u6df1\u4e00\u4e9b for(int k = 0; k < max_k; k++) { if ((depth[v] - depth[u]) >> k & 1) v = parent[k][v]; } if (u == v) return u; //\u4e8c\u5206\u641c\u7d22\u8ba1\u7b97LCA for (int k = max_k-1; k >= 0; k--) { if (parent[k][v] != parent[k][u]) { //\u5982\u679c\u8d85\u8fc7\u4e86\u4ed6\u4eec\u7684LCA\u4e5f\u4e00\u5b9a\u662f\u4e00\u6837\u7684,\u4e0d\u4e00\u6837\u4e00\u5b9a\u8fd8\u6ca1\u5230LCA v = parent[k][v], u = parent[k][u]; } } return parnet[0][u]; //?\u8fd9\u91cc\u597d\u50cf\u4e0d\u592a\u5bf9?// } 3.7.2 \u70b9\u5206\u6cbb \u6d1b\u8c37 P3806 POJ 1741 \u5176\u4ed6 \u5e38\u7528\u7ed3\u8bba \u5b9a\u4e49\uff1a \u5339\u914d\uff1a\u5728G\u4e2d\u4e24\u4e24\u6ca1\u6709\u516c\u5171\u70b9\u7684\u8fb9\u96c6\u5408M \u8fb9\u8986\u76d6\uff1aG\u4e2d\u4efb\u610f\u9876\u70b9\u90fd\u81f3\u5c11\u662fF\u4e2d\u67d0\u6761\u8fb9\u7684\u7aef\u70b9\u7684\u8fb9\u96c6\u5408F \u72ec\u7acb\u96c6\uff1a\u5728G\u4e2d\u4e24\u4e24\u4e92\u4e0d\u76f8\u8fde\u7684\u9876\u70b9\u96c6\u5408S \u9876\u70b9\u8986\u76d6\uff1aG\u4e2d\u7684\u4efb\u610f\u8fb9\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u5c5e\u4e8eS\u7684\u9876\u70b9\u96c6\u5408S \u7ed3\u8bba\uff1a \u5bf9\u4e8e\u65e0\u5b64\u7acb\u70b9\u7684\u56fe\uff0c|\u6700\u5927\u5339\u914d|+|\u6700\u5c0f\u8fb9\u8986\u76d6| = |V| |\u6700\u5927\u72ec\u7acb\u96c6|+|\u6700\u5c0f\u9876\u70b9\u8986\u76d6| = |V| \u5bf9\u4e8e\u4e8c\u5206\u56fe\uff0c|\u6700\u5927\u5339\u914d| = |\u6700\u5c0f\u9876\u70b9\u8986\u76d6| \u7b80\u5355\u8bc1\u660e\uff1a\u6700\u5927\u5339\u914d\u65f6\u662f\u6bcf\u4e00\u5bf9\u5339\u914d\u4e2d\uff0c\u4e0d\u53ef\u80fd2\u4e2a\u70b9\u90fd\u8fde\u63a5\u7740\u672a\u5339\u914d\u7684\u70b9\uff08\u4e0d\u7136\u7684\u8bdd\u5c31\u4f1a\u6709\u589e\u5e7f\u8def\u5f84\uff0c\u6700\u5927\u5339\u914d\u8fd8\u53ef\u4ee5\u66f4\u5927), \u6240\u4ee52\u4e2a\u70b9\u4e2d\u6700\u591a\u4e00\u4e2a\u70b9\u8fde\u63a5\u7740\u672a\u5339\u914d\u7684\u70b9\uff0c\u9009\u62e9\u90a3\u4e2a\u70b9\u4f5c\u4e3a\u6700\u5c0f\u5b9a\u70b9\u8986\u76d6\u5373\u53ef 2-SAT \u5e03\u5c14\u65b9\u7a0b\u7684\u53ef\u6ee1\u8db3\u6027\u95ee\u9898 \u5408\u53d6\u8303\u5f0f\uff1a \\( \\((a\\vee b\\vee\\dots)\\wedge(c\\vee d\\vee\\dots)\\) \\) 2-SAT\u95ee\u9898\uff1a\u5408\u53d6\u8303\u5f0f\u7684\u6bcf\u4e2a\u5b50\u53e5\u7684\u6587\u5b57\u4e0d\u8d85\u8fc72\u7684\u5e03\u5c14\u65b9\u7a0b\u7684\u53ef\u6ee1\u8db3\u6027\u95ee\u9898 \u5c06\u6bcf\u4e2a \\( \\(a\\vee b\\) \\) \u6539\u5199\u6210 \\( \\((\\urcorner a \\Rightarrow b \\wedge \\urcorner b \\Rightarrow a)\\) \\) \uff0c\u4ee5 \\( \\(\\Rightarrow\\) \\) \u5173\u7cfb\u4e3a\u8fb9\u5efa\u6709\u5411\u56fe\uff0c\u5229\u7528\u5f3a\u8fde\u901a\u5206\u91cf\u5206\u89e3 \u5982\u679c\u5b58\u5728 x\u548c \\( \\(\\urcorner x\\) \\) \u5b58\u5728\u540c\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\uff0c\u65e0\u89e3 \u5426\u5219\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5e03\u5c14\u53d8\u91cfx\uff0c\u5982\u679cx\u6240\u5728\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u7684\u62d3\u6251\u5e8f\u5728 \\( \\(\\urcorner x\\) \\) \u4e4b\u540e\uff0cx\u4e3atrue \u56e0\u4e3a\u62d3\u6251\u5e8f\u5728\u524d\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u53ef\u80fd\u5b58\u5728\u901a\u8def\u5230\u8fbe\u5728\u540e\u7684\uff0c\u6240\u4ee5\u5728\u540e\u7684\u4e00\u5b9a\u4e3atrue DFS\u5e8f \u5f53\u524d\u7ed3\u70b9\u7684 in \u548c out \u5305\u542b\u4e86\u5b50\u6811\u7684\u6240\u6709\u7ed3\u70b9 int in[N], out[N], tot = 0; void dfs(int x, int dep) { in[x] = ++tot; for (int i = 0; i < es[x].size(); i++) dfs(es[x][i], dep + 1); out[x] = tot; }","title":"\u56fe\u8bba"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#3","text":"","title":"3 \u56fe\u8bba"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#31","text":"","title":"3.1 \u56fe\u7684\u5b58\u50a8"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#311","text":"\u7565","title":"3.1.1 \u90bb\u63a5\u77e9\u9635"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#312","text":"vector<int> es[MAXN]; /* \u5e26\u6743\u8fb9 struct edge{ int to, w; }; vector<edge> es[MAXN]; */","title":"3.1.2 \u90bb\u63a5\u8868"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#313","text":"struct edge { int to, w, next; }es[MAX_E]; int cnt = 0; void init(){ memset(head, -1, sizeof head); } void add_edge(int u, int v, int w){ //\u52a0\u8fb9 es[cnt].to = v; es[cnt].w = w; es[cnt].next = head[u]; head[u] = cnt++; } /*\u904d\u5386 for(int i = 1; i <= n; i++) for(int j = head[i]; i != -1; j = es[j].next) /*...*/ */","title":"3.1.3 \u94fe\u5f0f\u524d\u5411\u661f"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#32","text":"","title":"3.2 \u6700\u77ed\u8def"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#bellman-ford","text":"\u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \\(O(VE)\\) \u652f\u6301\u8d1f\u6743 struct edge{ int from, to, w; }; edge es[MAX_E]; int d[MAX_V]; int V, E; void BF(int s){ memset(d, INF, sizeof d); d[s] = 0; for(int k = 0; k < V; k++){ for(int i = 0; i < E; i++){ edge e = es[i]; if(d[e.from] != INF && d[e.to] > d[e.from]+e.w){ d[e.to] = d[e.from]+w; //\u677e\u5f1b\u64cd\u4f5c } } } } //\u5faa\u73af\u81f3\u591a\u6267\u884c V-1 \u6b21\uff0c\u4e00\u6b21\u677e\u5f1b\u64cd\u4f5c\u81f3\u5c11\u8ba9\u786e\u5b9a\u7684\u6700\u77ed\u8def+1\uff0c\u6240\u4ee5O(VE)\uff0c\u5982\u679c\u7b2c n \u6b21\u4efb\u7136\u66f4\u65b0\u4e86d\uff0c\u8868\u793a\u6709\u8d1f\u73af //\u628a\u6240\u6709d[i]\u521d\u59cb\u5316\u4e3a0\uff0c\u5c31\u53ef\u4ee5\u627e\u5230\u6240\u6709\u7684\u8d1f\u5708 bool find_negative_loop(){ memset(d, 0, sizeof d); for(int i = 0; i < V; i++){ for(int j = 0; j < E; j++){ edge e = es[j]; if(d[e.to] > d[e.from]+e.w){ d[e.to] = d[e.from]+e.w; if(i == V-1) return true; } } } return false; }","title":"Bellman-Ford"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#dijkstra","text":"\u5355\u6e90\u6700\u77ed\u8def\u95ee\u9898 \u4e0d\u652f\u6301\u8d1f\u6743\u8fb9 \u68c0\u67e5\u5b58\u5728 \\(d[i][i]\\) \u4e3a\u8d1f\u6570\u6765\u5224\u65ad\u662f\u5426\u6709\u8d1f\u73af \\(O(ElogV)\\) \u7528\u4f18\u5148\u961f\u5217 typedef pair<int, int> P; vector<P> es[MAX_V]; //\u90bb\u63a5\u8868\u4e2dfirst\u8868\u793a\u7aef\u70b9\uff0csecond\u8868\u793a\u6743\u503c int d[MAX_V]; void dijkstra(int s) { priority_queue< P, vector<P>, greater<P> > que; //\u961f\u5217\u4e2dfirst\u8868\u793a\u6700\u77ed\u8def\uff0c second\u8868\u793a\u7aef\u70b9 memset(d, INF, sizeof d); d[s] = 0; que.push(P(0, s)); while(!que.empty()) { P p = que.top(); que.pop(); int u = p.second; if(d[u] < p.first) continue; for(int i = 0; i < es[u].size(); i++) { int v = es[u][i].first, w = es[u][i].second; if(d[v] > d[u]+w) //\u677e\u5f1b\u64cd\u4f5c { d[v] = d[u]+w; que.push(P(d[v], v)); } } } } \u94fe\u5f0f\u524d\u5411\u661f\u7684\u7248\u672c struct edge { int to, w, next; }edge[max_e]; struct node{ int to, w; bool operator < (const node& a) const{ return w > a.w; } }; int d[max_v], head[max_v], visited[max_v], n, m, cnt = 0; void init(){ memset(head, -1, sizeof head); } void add_edge(int u, int v, int w){ edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; } void dijkstra(int s){ priority_queue<node> que; fill(d, d+n+1, inf); memset(visited, false, sizeof visited); d[s] = 0; node tmp; tmp.to = s, tmp.w = 0; que.push(tmp); while(!que.empty()){ node t = que.top(); que.pop(); if(visited[t.to]) continue; visited[t.to] = true; for(int i = head[t.to]; i != -1; i = edge[i].next){ int v = edge[i].to; if(!visited[v] && d[v] > d[t.to]+edge[i].w){ d[v] = d[t.to]+edge[i].w; tmp.to = v, tmp.w = d[v]; que.push(tmp); } } } } int main(){ init(); scanf(\"%d %d\", &n, &m); int a, b, c; for(int i = 0; i < m; i++){ scanf(\"%d %d %d\", &a, &b, &c); add_edge(a, b, c); } dijkstra(1); printf(\"%d\\n\", d[n]); return 0; }","title":"Dijkstra"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#floyd-warshall","text":"\\(O(V^3)\\) dp:\u72b6\u6001\u8f6c\u79fb\u65b9\u65b9\u7a0b \\(d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][i])\\) , \u5373 \\(d[i][j] = min(dp[i][k], dp[k][j])\\) int d[MAX_V[MAX_V]; void floyd() { for(int k = 0; k < V; k++) for(int i = 0; i < V; i++) for(int j = 0; j < V; j++) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); }","title":"Floyd-Warshall"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#_1","text":"\u5728\u677e\u5f1b\u64cd\u4f5c\u65f6\u8bb0\u5f55\u6bcf\u4e2a\u7ed3\u70b9\u7684\u524d\u8d8b\u7ed3\u70b9 \\(path[i]\\) \u5373\u53ef, \u67e5\u8be2\u65f6\u4ece\u540e\u5f80\u524d\u904d\u5386","title":"\u8def\u5f84\u8fd8\u539f"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#_2","text":"//\u6bcf\u6b21\u66f4\u65b0\u6700\u77ed\u8def\u65f6\u770b\u770b\u88ab\u629b\u5f03\u7684\u503c\u80fd\u4e0d\u80fd\u66f4\u65b0\u6b21\u77ed\u8def typedef pair<int, int> P; const int inf = 0x3f3f3f3f; vector<P> es[max_v]; int n, r, a, b, c; int d1[max_v], d2[max_v]; //d2 \u6b21\u77ed\u8def void dijkstra(int s){ memset(d1, inf, sizeof d1); memset(d2, inf, sizeof d2); priority_queue< P, vector<P>, greater<P> > que; d1[s] = 0; que.push(P(0, s)); while(!que.empty()){ P p = que.top(); que.pop(); int u = p.second; if(d2[u] < p.first) continue; for(int i = 0; i < es[u].size(); i++){ int v = es[u][i].first, w = es[u][i].second; int tmp = p.first+w; if(d1[v] > tmp){ swap(tmp, d1[v]); que.push(P(d1[v], v)); } if(tmp < d2[v] && tmp > d1[v]){ d2[v] = tmp; que.push(P(d2[v], v)); } } } }","title":"\u6b21\u77ed\u8def"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#33","text":"\u524d\u63d0\uff1a\u56fe\u662f\u8fde\u901a\u7684","title":"3.3 \u6700\u5c0f\u751f\u6210\u6811"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#prim","text":"\\(O(V^2)\\) vector<edge> es[max_v]; int dis[MAX_V]; bool vis[MAX_V]; int prime(){ memset(dis, inf, sizeof dis); memset(vis, false, vis); dis[0] = 0; //s int res = 0; while(true){ int v = -1, mn = inf; for(int i = 0; i < V; i++) if(!visited[i] && dis[i] < mn) mn = dis[i], v = i; if(v == -1) break; vis[v] = true; res += mn; for(int i = 0; i < es[v].size(); i++){ edge e = es[v][i]; dis[e.to] = min(dis[e.to], e.w); } } return res; }","title":"Prim"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#kruskal","text":"\u6309\u7167\u8fb9\u7684\u6743\u503c\u4ece\u5c0f\u5230\u8fbe\uff0c\u5229\u7528\u5e76\u67e5\u96c6\u5224\u65ad\u662f\u5426\u4f1a\u4ea7\u51fa\u5708\uff0c\u4e0d\u4f1a\u5c31\u52a0\u5165 \\(O(ElogV)\\) struct edge{ int from, to, w; }; edge es[MAX_E]; bool cmp(edge a, edge b){ return a.w < b.w; } int kruskal(){ sort(es, es+E, cmp); init(MAX_V); //\u5e76\u67e5\u96c6\u7684\u521d\u59cb\u5316 int res = 0; for(int i = 0; i < E; i++){ edge e = es[i]; if(!same(e.from, e.to)){ unite(e.from, e.to); res += e.w; } } return res; }","title":"Kruskal"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#34","text":"","title":"3.4 \u7f51\u7edc\u6d41"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#dinic","text":"struct edge{ int to, cap, rev; } //rev\u8bb0\u5f55\u53cd\u5411\u8fb9\u5728 es[to] \u4e2d\u7684\u7d22\u5f15 vector<edge> es[max_v]; //\u90bb\u63a5\u8868 int level[max_v]; //\u5206\u5c42\u56fe int iter[max_v]; //\u5f27\u4f18\u5316\uff0c\u8bb0\u5f55\u7ed3\u70b9\u589e\u5e7f\u8fc7\u54ea\u4e9b\u8fb9\u4e86\uff0c\u4e0b\u6b21\u5c31\u4e0d\u589e\u5e7f\u4e86 void add_edge(int from, int to, int cap) {//\u52a0\u8fb9 es[from].push_back(edge{to, cap, es[to].size()}); es[to].push_back(edge{from, 0, es[from].size()-1}); } void bfs(int s) {//\u5206\u5c42\u56fe memset(level, -1, sizeof level); queue<int> que; level[s] = 0; que.push(s); while(!que.empty()){ int v = que.front(), que.pop(); for(int i = 0; i < es[i].size(); i++){ edge &e = es[v][i]; if(e.cap > 0 && level[e.to] < 0){ level[e.to] = level[v]+1; que.push(e.to); } } } } int dfs(int cur, int t, int f) { //\u589e\u5e7f\u8def if(cur == t) return f; for(int &i = iter[cur]; i < es[cur].size(); i++){ edge &e = es[cur][i]; if(e.cap > 0 && level[cur] < level[e.to]){ int d = dfs(e.to, t, min(f, e.cap)); if(d > 0) { e.cap -= d; es[e.to][e.rev].cap += d; return d; } } } return 0; } int max_flow(int s, int t){ int flow = 0; while(1){ bfs(s); if(level[t] < 0) return flow; memset(iter, 0, sizeof iter); int f; while(f = dfs(s, t, inf) > 0) flow += f; } }","title":"\u6700\u5927\u6d41 Dinic"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#_3","text":"\u8d1f\u6743\u8fb9\uff0c\u7528 BF \u7b97\u6cd5 const int inf = 0x3f3f3f3f; struct edge{int to, cap, cost, rev; } vector<edge> es[max_v]; int dist[max_v]; int pree[max_e], prev[max_v]; //\u524d\u5bfc\u9876\u70b9\u7684\u5bf9\u5e94\u7684\u8fb9\u7684\u7d22\u5f15 void add_edge(int from, int to, int cap, int cost){ es[from].push_back(edge{to, cap, cost, es[to].size()}); es[to].push_back(edge{from, 0, -cost, es[from].size()-1}); } int min_cost_flow(int s, int t, int f) { //\u8d77\u70b9 \u7ec8\u70b9 \u6d41\u91cf int res = 0; while(f > 0){ memset(dist, inf, sizeof dist); dist[s] = 0; while(true) bool update = false; for(int i = 0; i < V; i++) { if(dist[i] == inf) continue; for(int j = 0; j < es[i].size(); j++) { edge &e = es[i][j]; if(e.cap > 0 && dist[e.to] > dist[e.from]+e.cost) { dist[to] = dist[from]+e.cost; prev[e.to] = i; pree[e.to] = j; update = true; } } } if(!update) break; } if(dist[t] == inf) return -1; //\u6cbfs\u5230t\u7684\u6700\u77ed\u8def\u5c3d\u91cf\u589e\u5e7f int d = f; for(int i = t; i != s; i = prev[i]) d = min(d, es[prev[i]][pree[i]].cap); f -= d; res += d*dist[t]; for(int i = t; i != s; i = prev[i]) { edge &e = es[prev[i][pree[i]]]; e.cap -= d; es[i][e.rev].cap += d; } } return res; }","title":"\u6700\u5c0f\u8d39\u7528\u6d41"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#35","text":"","title":"3.5 \u4e8c\u5206\u56fe\u5339\u914d"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#351","text":"\u6dfb\u52a0\u539f\u70b9\u548c\u6c47\u70b9\uff0c\u8ba1\u7b97\u6700\u5927\u6d41 //\u8ba1\u7b97\u673a\u5904\u7406\u4efb\u52a1 bool can[max_n][max_m]; // can[i][j] : \u8ba1\u7b97\u673a i \u80fd\u5904\u7406\u4efb\u52a1 j void MaxMatch(){ //\u8ba1\u7b97\u673a\u5bf9\u5e94\u7684\u9876\u70b9\uff1a0 ~ n-1 //\u4efb\u52a1\u5bf9\u5e94\u7684\u9876\u70b9\uff1an ~ n+m-1 int s = n+m, t = n+m+1; for(int i = 0; i < n; i++){ add_edge(s, i, 1); } for(int i = 0; i < m; i++){ add_edge(n+i, t, 1); } for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) add_edge(i, n+j, 1); cout << max_flow(s, t) << endl; }","title":"3.5.1 \u6700\u5927\u6d41"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#352","text":"\\(O(VE)\\) bool vis[max_v]; int match[max_v]; vector<int> es[max_v]; void add_edge(int u, int v){ es[u].push_back(v); es[v].push_back(u); } bool dfs(int cur){ for(int i = 0; i < es[cur].size(); i++){ int v = es[cur][i]; if(vis[v]) continue; vis[v] = true; if(!match[v] || dfs(match[v])){ match[v] = cur; match[cur] = v; return true; } } return false; } int MaxMatch(){ int res = 0; for(int i = 1; i <= n; i++){ //\u5bfb\u627e\u589e\u5e7f\u8def\u5f84 memset(vis, 0, sizeof vis); if(!match[i] && dfs(i)) res++; } return res; }","title":"3.5.2 \u5308\u7259\u5229\u7b97\u6cd5"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#353-hopcroft-karp","text":"\\(O(E\\sqrt{V})\\) HDU 2389 int match[max_v], dep[max_v]; vector<int> es[max_v]; bool bfs() { memset(dep, 0, sizeof dep); queue<int> q; for (int i = 1; i <= n; i++) if (!match[i]) q.push(i); bool flag = false; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i < es[u].size(); i++) { int v = es[u][i]; if (dep[v]) continue; dep[v] = dep[u] + 1; if (!match[v]) flag = true; else dep[match[v]] = dep[v] + 1, q.push(match[v]); } } return flag; } bool dfs(int u) { for (int i = 0; i < es[u].size(); i++) { int v = es[u][i]; if (dep[v] != dep[u] + 1) continue; dep[v] = 0; if (!match[v] || dfs(match[v])) { match[v] = u; match[u] = v; return true; } } return false; } int MaxMatch() { int res = 0; while (bfs()) { for (int i = 1; i <= n; i++) if (!match[i] && dfs(i)) res++; } return res; }","title":"3.5.3 Hopcroft-Karp"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#36","text":"","title":"3.6 \u8fde\u901a\u6027\u76f8\u5173"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#361","text":"\\[O(V+E)\\] \u4e24\u6b21DFS\uff0c\u7b2c\u4e00\u904d\u540e\u5e8f\u904d\u5386\u5e76\u7ed9\u9876\u70b9\u6807\u53f7\uff0c\u7b2c\u4e8c\u904d\u5bf9\u53cd\u5411\u56fe\u904d\u5386 vector<int> G[max_v]; vector<int> rG[max_v]; //\u53cd\u5411\u56fe vector<int> vs; //vertex sequence bool vis[max_v]; int cmp[max_v]; //\u6240\u5c5e\u5f3a\u8fde\u901a\u56fe\u7684\u62d3\u6251\u5e8f void add_edge(int u, int v){ G[u].push_back(v); rG[v].push_back(u); } void dfs(int v){ vis[v] = true; for(int i = 0; i < G[v].size(); i++) if(!vis[G[v][i]]) dfs(G[v][i]); vs.push_back(v); } void rdfs(int v, int k){ vis[v] = true; cmp[v] = k; for(int i = 0; i < rG[v].size(); i++) if(!vis[rG[v][i]]) rdfs(rG[v][i], k); } int scc() { //strongly connected component memset(vis, false, sizeof vis); vs.clear(); for(int v = 0; v < V; v++) if(!vis[v]) dfs(v); memset(vis, false, sizeof vis); int k = 0; for(int i = vs.size()-1; i >= 0; i--) if(!vis[vs[i]]) rdfs(vs[i], k++); return k; }","title":"3.6.1 \u5f3a\u8fde\u901a\u5206\u91cf\u5206\u89e3"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#362","text":"\u5e76\u67e5\u96c6","title":"3.6.2 \u8fde\u901a\u5206\u652f\u4e2a\u6570"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#37","text":"","title":"3.7 \u6811\u4e0a\u95ee\u9898"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#371-lca","text":"\\[O(n)\\] vector<int> G[maxn_v]; int root, parent[max_v], depth[max_v]; void dfs(int v, int p, int d){ parent[v] = p, depth[v] = d; for(int i = 0; i < G[v].size(); i++) if(G[v][i] != p) dfs(G[v][i], v, d+1); } void init(){ dfs(root, -1, 0); } int lca(int u, int v){ //\u5148\u628au,v\u8d70\u5230\u540c\u4e00\u6df1\u5ea6 while(depth[u] > depth[v]) u = parent[u]; while(depth[v] > depth[u]) v = parent[v]; //\u4e00\u8d77\u5411\u4e0a\u8d70 while(u != v){ u = parent[u], v = parent[v]; } return u; } \u57fa\u4e8e\u4e8c\u5206\u641c\u7d22\u7684\u7b97\u6cd5 \u5bf9\u4e8e\u4efb\u610f\u7ed3\u70b9v\uff0c\u53ef\u4ee5\u901a\u8fc7 parent2[v] = parent[parent[v]] parent4[v] = parent2[parent2[v]] ... \u5f97\u5230\u5176\u5411\u4e0a\u8d70 \\( \\(2^k\\) \\) \u6b65\u5230\u8fbe\u7684\u9876\u70b9 \u6bcf\u6b21\u641c\u7d22\u7684\u590d\u6742\u5ea6\uff1a \\( \\(O(logn)\\) \\) \uff0c\u9884\u5904\u7406\u7684\u590d\u6742\u5ea6\uff1a \\( \\(O(nlogn)\\) \\) vector<int> G[max_v]; int root, parent[max_k][max_v], depth[max_v]; void dfs(int v, int p, int d){ depth[v] = d, parent[v] = p; for(int i = 0; i < G[v].size(); i++) if(G[v][i] != p) dfs(G[v][i], v, d+1); } void init(int V){ //\u9884\u5904\u7406parent[0]\u548cdepth dfs(root, -1, 0); //\u9884\u5904\u7406parent for(int k = 0; k+1 < max_k; k++) for(int i = 0; i < V; i++) { //parent[k][v] \u8868\u793a\u4ece v \u7ed3\u70b9\u5411\u4e0a\u8d70 2^k \u6b21\u7684\u7ed3\u70b9\uff0c \u8d85\u8fc7\u6839\u65f6\u8bb0\u4f5c-1 if(parent[k][i] < 0) parent[k+1][i] = -1; else parent[k+1][i] = parent[k][parent[k][i]]; } } int lca(int u, int v){ //\u8ba9u\u548cv\u8d70\u5230\u540c\u4e00\u6df1\u5ea6 if(depth[u] > depth[v]) swap(u, v); //\u8ba9v\u7684\u6df1\u5ea6\u6df1\u4e00\u4e9b for(int k = 0; k < max_k; k++) { if ((depth[v] - depth[u]) >> k & 1) v = parent[k][v]; } if (u == v) return u; //\u4e8c\u5206\u641c\u7d22\u8ba1\u7b97LCA for (int k = max_k-1; k >= 0; k--) { if (parent[k][v] != parent[k][u]) { //\u5982\u679c\u8d85\u8fc7\u4e86\u4ed6\u4eec\u7684LCA\u4e5f\u4e00\u5b9a\u662f\u4e00\u6837\u7684,\u4e0d\u4e00\u6837\u4e00\u5b9a\u8fd8\u6ca1\u5230LCA v = parent[k][v], u = parent[k][u]; } } return parnet[0][u]; //?\u8fd9\u91cc\u597d\u50cf\u4e0d\u592a\u5bf9?// }","title":"3.7.1 \u6700\u8fd1\u516c\u5171\u7956\u5148(LCA)"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#372","text":"\u6d1b\u8c37 P3806 POJ 1741","title":"3.7.2 \u70b9\u5206\u6cbb"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#_4","text":"","title":"\u5176\u4ed6"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#_5","text":"\u5b9a\u4e49\uff1a \u5339\u914d\uff1a\u5728G\u4e2d\u4e24\u4e24\u6ca1\u6709\u516c\u5171\u70b9\u7684\u8fb9\u96c6\u5408M \u8fb9\u8986\u76d6\uff1aG\u4e2d\u4efb\u610f\u9876\u70b9\u90fd\u81f3\u5c11\u662fF\u4e2d\u67d0\u6761\u8fb9\u7684\u7aef\u70b9\u7684\u8fb9\u96c6\u5408F \u72ec\u7acb\u96c6\uff1a\u5728G\u4e2d\u4e24\u4e24\u4e92\u4e0d\u76f8\u8fde\u7684\u9876\u70b9\u96c6\u5408S \u9876\u70b9\u8986\u76d6\uff1aG\u4e2d\u7684\u4efb\u610f\u8fb9\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u5c5e\u4e8eS\u7684\u9876\u70b9\u96c6\u5408S \u7ed3\u8bba\uff1a \u5bf9\u4e8e\u65e0\u5b64\u7acb\u70b9\u7684\u56fe\uff0c|\u6700\u5927\u5339\u914d|+|\u6700\u5c0f\u8fb9\u8986\u76d6| = |V| |\u6700\u5927\u72ec\u7acb\u96c6|+|\u6700\u5c0f\u9876\u70b9\u8986\u76d6| = |V| \u5bf9\u4e8e\u4e8c\u5206\u56fe\uff0c|\u6700\u5927\u5339\u914d| = |\u6700\u5c0f\u9876\u70b9\u8986\u76d6| \u7b80\u5355\u8bc1\u660e\uff1a\u6700\u5927\u5339\u914d\u65f6\u662f\u6bcf\u4e00\u5bf9\u5339\u914d\u4e2d\uff0c\u4e0d\u53ef\u80fd2\u4e2a\u70b9\u90fd\u8fde\u63a5\u7740\u672a\u5339\u914d\u7684\u70b9\uff08\u4e0d\u7136\u7684\u8bdd\u5c31\u4f1a\u6709\u589e\u5e7f\u8def\u5f84\uff0c\u6700\u5927\u5339\u914d\u8fd8\u53ef\u4ee5\u66f4\u5927), \u6240\u4ee52\u4e2a\u70b9\u4e2d\u6700\u591a\u4e00\u4e2a\u70b9\u8fde\u63a5\u7740\u672a\u5339\u914d\u7684\u70b9\uff0c\u9009\u62e9\u90a3\u4e2a\u70b9\u4f5c\u4e3a\u6700\u5c0f\u5b9a\u70b9\u8986\u76d6\u5373\u53ef","title":"\u5e38\u7528\u7ed3\u8bba"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#2-sat","text":"\u5e03\u5c14\u65b9\u7a0b\u7684\u53ef\u6ee1\u8db3\u6027\u95ee\u9898 \u5408\u53d6\u8303\u5f0f\uff1a \\( \\((a\\vee b\\vee\\dots)\\wedge(c\\vee d\\vee\\dots)\\) \\) 2-SAT\u95ee\u9898\uff1a\u5408\u53d6\u8303\u5f0f\u7684\u6bcf\u4e2a\u5b50\u53e5\u7684\u6587\u5b57\u4e0d\u8d85\u8fc72\u7684\u5e03\u5c14\u65b9\u7a0b\u7684\u53ef\u6ee1\u8db3\u6027\u95ee\u9898 \u5c06\u6bcf\u4e2a \\( \\(a\\vee b\\) \\) \u6539\u5199\u6210 \\( \\((\\urcorner a \\Rightarrow b \\wedge \\urcorner b \\Rightarrow a)\\) \\) \uff0c\u4ee5 \\( \\(\\Rightarrow\\) \\) \u5173\u7cfb\u4e3a\u8fb9\u5efa\u6709\u5411\u56fe\uff0c\u5229\u7528\u5f3a\u8fde\u901a\u5206\u91cf\u5206\u89e3 \u5982\u679c\u5b58\u5728 x\u548c \\( \\(\\urcorner x\\) \\) \u5b58\u5728\u540c\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\uff0c\u65e0\u89e3 \u5426\u5219\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5e03\u5c14\u53d8\u91cfx\uff0c\u5982\u679cx\u6240\u5728\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u7684\u62d3\u6251\u5e8f\u5728 \\( \\(\\urcorner x\\) \\) \u4e4b\u540e\uff0cx\u4e3atrue \u56e0\u4e3a\u62d3\u6251\u5e8f\u5728\u524d\u7684\u5f3a\u8fde\u901a\u5206\u91cf\u53ef\u80fd\u5b58\u5728\u901a\u8def\u5230\u8fbe\u5728\u540e\u7684\uff0c\u6240\u4ee5\u5728\u540e\u7684\u4e00\u5b9a\u4e3atrue","title":"2-SAT"},{"location":"OI/%E5%9B%BE%E8%AE%BA/#dfs","text":"\u5f53\u524d\u7ed3\u70b9\u7684 in \u548c out \u5305\u542b\u4e86\u5b50\u6811\u7684\u6240\u6709\u7ed3\u70b9 int in[N], out[N], tot = 0; void dfs(int x, int dep) { in[x] = ++tot; for (int i = 0; i < es[x].size(); i++) dfs(es[x][i], dep + 1); out[x] = tot; }","title":"DFS\u5e8f"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/","text":"\u5b57\u7b26\u4e32 next\u6570\u7ec4 \u4e0e KMP \\(O(n+m)\\) //next void getNext(char *p, int *next) { next[0] = -1; int i = 0, j = -1; while(i < strlen(p)) if(j == -1 || p[i] == p[j]){ i++, j++; next[i] = j; } else j = next[j]; } //KMP //\u4e3b\u4f53\u5b57\u7b26\u4e32 \u5339\u914d\u5b57\u7b26\u4e32 int KMP(char *s, char *p){ int i = 0; int j = 0; while(i < strlen(s) && j < strlen(p)) if(j == -1 || s[i] == p[j]) i++, j++; else j = next[j]; //\u8fd4\u56de\u5b58\u5728\u4e0e p \u76f8\u540c\u7684\u5b57\u4e32\u7684\u4f4d\u7f6e if(j == strlen(p)) return i-j; else return -1; } Manacher \\(O(n)\\) //Manacher int Manacher(string s){ if(s.length() == 0) return 0; int len = (int)(s.length()*2-1); char *cArry = new char[len]; int *pArry = new int[len]; //\u9884\u5904\u7406\uff1a\u5168\u90fd\u53d8\u6210\u5947\u6570\u56de\u6587\u4e32 for(int i = 0; i < len; i++) cArry[i] = i&1 ? s[(i-1)/2] : '#'; //R:\u6700\u53f3\u53f3\u8fb9\u754c C\uff1a\u4e0eR\u5bf9\u5e94\u7684\u56de\u6587\u4e2d\u5fc3 maxn\uff1a\u6700\u5927\u56de\u6587\u534a\u5f84\uff0c\u8fd4\u56de\u503c\u4e3amaxn-1 //R\u5b9e\u9645\u4e0a\u662f\u6700\u53f3\u8fb9\u754c\u7684\u53f3\u8fb9\u4e00\u4f4d int R = -1; int C = -1; int maxn = 0; for(int i = 0; i < len; i++){ pArry[i] = i >= R ? 1 : min(R-i, pArry[2*C-i]); //\u53d6\u5f97\u53ef\u80fd\u7684\u6700\u77ed\u7684\u56de\u6587\u534a\u5f84 *R\u662f\u6700\u53f3\u8fb9\u754c\u7684\u53f3\u8fb9\u4e00\u4f4d //\u66b4\u529b\u8ba1\u7b97 while(i+pArry[i] < len && i-pArry[i] > -1){ if(cArry[i+pArry[i]] == cArry[i-pArry[i]]) pArry[i]++; else break; } //\u66f4\u65b0 if(i+pArry[i] > R){ R = i+pArry[i]; C = i; } maxn = maxn(pArry[i], maxn); } //\u6e05\u7a7a\u52a8\u6001\u6570\u7ec4 delete[] cArry; delete[] pArry; return maxn-1; } \u6700\u5c0f\u8868\u793a\u6cd5 \\(O(n)\\) //\u6700\u5c0f\u8868\u793a\u6cd5 int min_(char *s){ int k = 0, i = 0, j = 1, len = strlen(s); // k:\u5339\u914d\u957f\u5ea6 while(k < len && i < len && j < len){ if(s[(s+k)%len] == s[(j+k)%len]) k++; else { s[(s + k) % len] > s[(j + k) % len] ? i = i+k+1 : j = j+k+1;//\u4e0d\u540c\u5219\u8df3\u8f6c if(i == j) i++; //\u82e5\u8df3\u8f6c\u540e\u4e0d\u540c\uff0c\u8981\u4fdd\u8bc1\u6bd4\u8f83\u7684\u53cc\u65b9\u4e0d\u540c k = 0; } } return min(i, j); } \u7ec3\u4e60\u9898 next \u4e0e KMP HDU 1711 HDU 2087 POJ 3461 POJ 2752 HDU 2594 POJ 2406 HDU 3746 POJ 3080 HDU 3336 HDU 3374 String Problem Manacher HDU 3068 HDU 4513 POJ 3974 HDU 3294 \u6700\u5c0f\u8868\u793a\u6cd5 HDU 3374 String Problem","title":"\u5b57\u7b26\u4e32"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#_1","text":"","title":"\u5b57\u7b26\u4e32"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#next-kmp","text":"\\(O(n+m)\\) //next void getNext(char *p, int *next) { next[0] = -1; int i = 0, j = -1; while(i < strlen(p)) if(j == -1 || p[i] == p[j]){ i++, j++; next[i] = j; } else j = next[j]; } //KMP //\u4e3b\u4f53\u5b57\u7b26\u4e32 \u5339\u914d\u5b57\u7b26\u4e32 int KMP(char *s, char *p){ int i = 0; int j = 0; while(i < strlen(s) && j < strlen(p)) if(j == -1 || s[i] == p[j]) i++, j++; else j = next[j]; //\u8fd4\u56de\u5b58\u5728\u4e0e p \u76f8\u540c\u7684\u5b57\u4e32\u7684\u4f4d\u7f6e if(j == strlen(p)) return i-j; else return -1; }","title":"next\u6570\u7ec4 \u4e0e KMP"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#manacher","text":"\\(O(n)\\) //Manacher int Manacher(string s){ if(s.length() == 0) return 0; int len = (int)(s.length()*2-1); char *cArry = new char[len]; int *pArry = new int[len]; //\u9884\u5904\u7406\uff1a\u5168\u90fd\u53d8\u6210\u5947\u6570\u56de\u6587\u4e32 for(int i = 0; i < len; i++) cArry[i] = i&1 ? s[(i-1)/2] : '#'; //R:\u6700\u53f3\u53f3\u8fb9\u754c C\uff1a\u4e0eR\u5bf9\u5e94\u7684\u56de\u6587\u4e2d\u5fc3 maxn\uff1a\u6700\u5927\u56de\u6587\u534a\u5f84\uff0c\u8fd4\u56de\u503c\u4e3amaxn-1 //R\u5b9e\u9645\u4e0a\u662f\u6700\u53f3\u8fb9\u754c\u7684\u53f3\u8fb9\u4e00\u4f4d int R = -1; int C = -1; int maxn = 0; for(int i = 0; i < len; i++){ pArry[i] = i >= R ? 1 : min(R-i, pArry[2*C-i]); //\u53d6\u5f97\u53ef\u80fd\u7684\u6700\u77ed\u7684\u56de\u6587\u534a\u5f84 *R\u662f\u6700\u53f3\u8fb9\u754c\u7684\u53f3\u8fb9\u4e00\u4f4d //\u66b4\u529b\u8ba1\u7b97 while(i+pArry[i] < len && i-pArry[i] > -1){ if(cArry[i+pArry[i]] == cArry[i-pArry[i]]) pArry[i]++; else break; } //\u66f4\u65b0 if(i+pArry[i] > R){ R = i+pArry[i]; C = i; } maxn = maxn(pArry[i], maxn); } //\u6e05\u7a7a\u52a8\u6001\u6570\u7ec4 delete[] cArry; delete[] pArry; return maxn-1; }","title":"Manacher"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#_2","text":"\\(O(n)\\) //\u6700\u5c0f\u8868\u793a\u6cd5 int min_(char *s){ int k = 0, i = 0, j = 1, len = strlen(s); // k:\u5339\u914d\u957f\u5ea6 while(k < len && i < len && j < len){ if(s[(s+k)%len] == s[(j+k)%len]) k++; else { s[(s + k) % len] > s[(j + k) % len] ? i = i+k+1 : j = j+k+1;//\u4e0d\u540c\u5219\u8df3\u8f6c if(i == j) i++; //\u82e5\u8df3\u8f6c\u540e\u4e0d\u540c\uff0c\u8981\u4fdd\u8bc1\u6bd4\u8f83\u7684\u53cc\u65b9\u4e0d\u540c k = 0; } } return min(i, j); }","title":"\u6700\u5c0f\u8868\u793a\u6cd5"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#_3","text":"","title":"\u7ec3\u4e60\u9898"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#next-kmp_1","text":"HDU 1711 HDU 2087 POJ 3461 POJ 2752 HDU 2594 POJ 2406 HDU 3746 POJ 3080 HDU 3336 HDU 3374 String Problem","title":"next \u4e0e KMP"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#manacher_1","text":"HDU 3068 HDU 4513 POJ 3974 HDU 3294","title":"Manacher"},{"location":"OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/#_4","text":"HDU 3374 String Problem","title":"\u6700\u5c0f\u8868\u793a\u6cd5"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","text":"\u6570\u636e\u7ed3\u6784 \u6811\u72b6\u6570\u7ec4 \u5355\u70b9\u66f4\u65b0 \u533a\u95f4\u67e5\u8be2 int a[maxn],c[maxn]; //\u539f\u6570\u7ec4\u548c\u6811\u72b6\u6570\u7ec4 int lowbit(int x){ return x&(-x); } void updata(int i,int k) //\u7b2c i \u4e2a\u5143\u7d20\u52a0 k { while(i <= n) { c[i] += k; i += lowbit(i); } } int getsum(int i) //\u524di\u4e2a\u548c { int res = 0; while(i > 0) { res += c[i]; i -= lowbit(i); } return res; } \u533a\u95f4\u66f4\u65b0 \u5355\u70b9\u67e5\u8be2 //\u5229\u7528\u539f\u6570\u7ec4\u7684\u5dee\u5206\u6570\u7ec4\u5efa\u6811 int a[maxn] = {0},c[maxn]; //\u539f\u6570\u7ec4\u548c\u6811\u72b6\u6570\u7ec4 int lowbit(int x){ return x&(-x); } void updata(int i,int k) //\u7b2c i \u4e2a\u5143\u7d20\u52a0 k { while(i <= n) { c[i] += k; i += lowbit(i); } } int getsum(int i) //\u524di\u4e2a { int res = 0; while(i > 0) { res += c[i]; i -= lowbit(i); } return res; } /* updata(i,a[i] - a[i-1]); //\u5dee\u5206\u5efa\u6811 //[x,y]\u533a\u95f4\u5185\u52a0\u4e0ak updata(x,k); //A[x] - A[x-1]\u589e\u52a0k updata(y+1,-k); //A[y+1] - A[y]\u51cf\u5c11k //\u5355\u70b9\u67e5\u8be2 \u5dee\u5206\u5efa\u6811\u6240\u4ee5\u5355\u70b9\u67e5\u8be2\u53d8\u6210\u4e86\u6c42\u548c int sum = getsum(i); */ \u533a\u95f4\u66f4\u65b0 \u533a\u95f4\u67e5\u8be2 d \u662f a \u7684\u5dee\u5206\u6570\u7ec4 \u6709 \\(a_i = \\sum_{j=1}^{i}{d_j}\\) $\\therefore\\sum_{i=1}^{r}{a_i} = \\sum_{i=1}^{r}{\\sum_{j=1}^{i}{d_j}} $ \u200b \\(= \\sum_{i=1}^{r}{d_i \\times(r-i+1)}\\) \u200b $ = \\sum_{i=1}^{r}{d_i \\times(r+1)}-\\sum_{i=1}^{r}{d_i \\times i}$ \u6240\u4ee5\u7ef4\u62a42\u4e2a\u6811\u72b6\u6570\u7ec4 sum1[i] = d[i]\uff0csum2[i] = d[i]*(i-1) \u7ebf\u6bb5\u6811 /*\u533a\u95f4\u548c\u7684\u7ebf\u6bb5\u6811*/ //\u5efa\u6811 void build(ll x, ll l, ll r) { if (l == r) { scanf(\"%lld\", &sum[x]); return; } ll mid = (l + r) >> 1; build(x << 1, l, mid); build(x << 1 | 1, mid + 1, r); sum[x] = sum[x << 1] + sum[x << 1 | 1]; } //\u4e0b\u653e\u61d2\u6807\u8bb0 void pushdown(ll x, ll l, ll r) { ll mid = (l + r) / 2; lz[x << 1] += lz[x], lz[x << 1 | 1] += lz[x]; sum[x << 1] += lz[x] * (mid - l + 1), sum[x << 1 | 1] += lz[x] * (r - mid); lz[x] = 0; } //\u533a\u95f4\u66f4\u65b0 void update(ll x, ll l, ll r, ll gl, ll gr, ll k) { if (l >= gl && r <= gr) { lz[x] += k; sum[x] += (r - l + 1) * k; return; } pushdown(x, l, r); ll mid = (l + r) / 2; if (gl <= mid) update(x << 1, l, mid, gl, gr, k); if (gr > mid) update(x << 1 | 1, mid + 1, r, gl, gr, k); sum[x] = sum[x << 1] + sum[x << 1 | 1]; } //\u533a\u95f4\u548c ll get_sum(ll x, ll l, ll r, ll gl, ll gr) { if (l >= gl && r <= gr) return sum[x]; pushdown(x, l, r); ll res = 0; ll mid = (l + r) / 2; if (gl <= mid) res += get_sum(x << 1, l, mid, gl, gr); if (gr > mid) res += get_sum(x << 1 | 1, mid + 1, r, gl, gr); return res; } \u4e58\u6cd5\u7ebf\u6bb5\u6811 \u6839\u53f7\u7ebf\u6bb5\u6811 \u5e76\u67e5\u96c6 int fa[MAXN]; //\u521d\u59cb\u5316 void init(int n){ for(int i = 0; i < n; i++) fa[i] = i; //\u7236\u7ed3\u70b9\u662f\u81ea\u5df1 } //\u67e5\u8be2\u5e76\u8def\u5f84\u538b\u7f29 int find(int x){ if(fa[x] != x) fa[x] = find(fa[x]); return fa[x]; } //\u5408\u5e76 void unite(int x, int y){ int fx = find(x); int fy = find(y); fa[fx] = fy; } //\u67e5\u8be2\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u96c6\u5408 bool same(int x, int y){ return find(x) == find(y); } \u5e26\u6743\u5e76\u67e5\u96c6 int fa[MAXN], value[MAXN]; //\u7236\u7ed3\u70b9 \u6743\u503c //\u67e5\u8be2 int find(int x){ if(x != fa[x]){ int t = fa[x]; fa[x] = find(fa[x]); value[x] += value[t]; //\u8fd9\u65f6\u7684\u7236\u4eb2\u7ed3\u70b9\u7684\u6743\u503c\u662f\u7236\u7ed3\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u6743\u503c //\u6240\u4ee5\u52a0\u4e0a\u539f\u672c\u81ea\u5df1\u5230\u7236\u7ed3\u70b9\u7684\u6743\u503c\u5c31\u662f\u81ea\u5df1\u5230\u6839\u7ed3\u70b9\u7684\u6743\u503c } return fa[x]; } //\u5408\u5e76, s\u662fx->y\u7684\u6743\u503c void unite(int x, int y, int s){ int px = find(x); int py = find(y); if(px != py){ fa[px] = py; value[px] = s+value[y]-value[x]; //x->y->py\u7684\u6743\u503c = x->px->py\u7684\u6743\u503c\uff0c\u6240\u4ee5\u5f97px->py\u7684\u6743\u503c\u4e3a\u4e0a\u5f0f } } \u6808 \u5355\u8c03\u6808 //\u6c42\u51fa\u6bcf\u4e2a\u5143\u7d20\u5de6\u53f3\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u5b83\u7684\u5143\u7d20\u7684\u4e0b\u6807 for(int i = 1; i <= n; i++) { while(!st.empty() && num[st.top()] > num[i]) { r[st.top()] = i; st.pop(); } if(st.empty()) l[i] = -1; else if(num[st.top()] == num[i]) l[i] = l[st.top()]; else l[i] = st.top(); st.push(i); } while(!st.empty()) { r[st.top()] = n+1; st.pop(); } \u53ef\u6301\u4e45\u5316\u6570\u636e\u7ed3\u6784 \u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811(\u4e3b\u5e2d\u6811) \u6d1b\u8c37 P3834 //\u4e00\u822c\u5f0032\u500d\u7a7a\u95f4 const int maxn = 2e5 + 5; int a[maxn], b[maxn], n, m, tot, q; int lc[maxn << 5], rc[maxn << 5], sum[maxn << 5], rt[maxn << 5]; void build(int &rt, int l, int r) { rt = ++tot, sum[rt] = 0; if (l == r) return; int mid = (l + r) >> 1; build(lc[rt], l, mid), build(rc[rt], mid + 1, r); } int update(int x, int l, int r, int t) { int xx = ++tot; lc[xx] = lc[x], rc[xx] = rc[x], sum[xx] = sum[x] + 1; if (l == r) return xx; int mid = (l + r) >> 1; if (t <= mid) lc[xx] = update(lc[xx], l, mid, t); else rc[xx] = update(rc[xx], mid + 1, r, t); return xx; } int query(int u, int v, int l, int r, int k) { int mid = (l + r) >> 1, t = sum[lc[v]] - sum[lc[u]]; if (l == r) return l; if (k <= t) return query(lc[u], lc[v], l, mid, k); else return query(rc[u], rc[v], mid + 1, r, k - t); } int main() { cin >> n >> m; for (int i = 1; i <= m; i++) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + 1 + n); q = unique(b + 1, b + 1 + n) - b - 1; build(rt[0], 1, q); for (int i = 1; i <= n; i++) { int t = lower_bound(b + 1, b + 1 + q, a[i]) - b; rt[i] = update(rt[i - 1], 1, q, t); } int l, r, k; for (int i = 1; i <= m; i++) { scanf(\"%d %d %d\", &l, &r, &k); printf(\"%d\\n\", b[query(rt[l - 1], rt[r], 1, q, k)]); } return 0; } \u4e8c\u4f4d\u524d\u7f00\u548c //\u9884\u5904\u7406 for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j]; //x1, y1, x2, y2 (\u67e5\u8be2\u533a\u95f4) int res = dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1];","title":"\u6570\u636e\u7ed3\u6784"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_1","text":"","title":"\u6570\u636e\u7ed3\u6784"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_2","text":"\u5355\u70b9\u66f4\u65b0 \u533a\u95f4\u67e5\u8be2 int a[maxn],c[maxn]; //\u539f\u6570\u7ec4\u548c\u6811\u72b6\u6570\u7ec4 int lowbit(int x){ return x&(-x); } void updata(int i,int k) //\u7b2c i \u4e2a\u5143\u7d20\u52a0 k { while(i <= n) { c[i] += k; i += lowbit(i); } } int getsum(int i) //\u524di\u4e2a\u548c { int res = 0; while(i > 0) { res += c[i]; i -= lowbit(i); } return res; } \u533a\u95f4\u66f4\u65b0 \u5355\u70b9\u67e5\u8be2 //\u5229\u7528\u539f\u6570\u7ec4\u7684\u5dee\u5206\u6570\u7ec4\u5efa\u6811 int a[maxn] = {0},c[maxn]; //\u539f\u6570\u7ec4\u548c\u6811\u72b6\u6570\u7ec4 int lowbit(int x){ return x&(-x); } void updata(int i,int k) //\u7b2c i \u4e2a\u5143\u7d20\u52a0 k { while(i <= n) { c[i] += k; i += lowbit(i); } } int getsum(int i) //\u524di\u4e2a { int res = 0; while(i > 0) { res += c[i]; i -= lowbit(i); } return res; } /* updata(i,a[i] - a[i-1]); //\u5dee\u5206\u5efa\u6811 //[x,y]\u533a\u95f4\u5185\u52a0\u4e0ak updata(x,k); //A[x] - A[x-1]\u589e\u52a0k updata(y+1,-k); //A[y+1] - A[y]\u51cf\u5c11k //\u5355\u70b9\u67e5\u8be2 \u5dee\u5206\u5efa\u6811\u6240\u4ee5\u5355\u70b9\u67e5\u8be2\u53d8\u6210\u4e86\u6c42\u548c int sum = getsum(i); */ \u533a\u95f4\u66f4\u65b0 \u533a\u95f4\u67e5\u8be2 d \u662f a \u7684\u5dee\u5206\u6570\u7ec4 \u6709 \\(a_i = \\sum_{j=1}^{i}{d_j}\\) $\\therefore\\sum_{i=1}^{r}{a_i} = \\sum_{i=1}^{r}{\\sum_{j=1}^{i}{d_j}} $ \u200b \\(= \\sum_{i=1}^{r}{d_i \\times(r-i+1)}\\) \u200b $ = \\sum_{i=1}^{r}{d_i \\times(r+1)}-\\sum_{i=1}^{r}{d_i \\times i}$ \u6240\u4ee5\u7ef4\u62a42\u4e2a\u6811\u72b6\u6570\u7ec4 sum1[i] = d[i]\uff0csum2[i] = d[i]*(i-1)","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_3","text":"/*\u533a\u95f4\u548c\u7684\u7ebf\u6bb5\u6811*/ //\u5efa\u6811 void build(ll x, ll l, ll r) { if (l == r) { scanf(\"%lld\", &sum[x]); return; } ll mid = (l + r) >> 1; build(x << 1, l, mid); build(x << 1 | 1, mid + 1, r); sum[x] = sum[x << 1] + sum[x << 1 | 1]; } //\u4e0b\u653e\u61d2\u6807\u8bb0 void pushdown(ll x, ll l, ll r) { ll mid = (l + r) / 2; lz[x << 1] += lz[x], lz[x << 1 | 1] += lz[x]; sum[x << 1] += lz[x] * (mid - l + 1), sum[x << 1 | 1] += lz[x] * (r - mid); lz[x] = 0; } //\u533a\u95f4\u66f4\u65b0 void update(ll x, ll l, ll r, ll gl, ll gr, ll k) { if (l >= gl && r <= gr) { lz[x] += k; sum[x] += (r - l + 1) * k; return; } pushdown(x, l, r); ll mid = (l + r) / 2; if (gl <= mid) update(x << 1, l, mid, gl, gr, k); if (gr > mid) update(x << 1 | 1, mid + 1, r, gl, gr, k); sum[x] = sum[x << 1] + sum[x << 1 | 1]; } //\u533a\u95f4\u548c ll get_sum(ll x, ll l, ll r, ll gl, ll gr) { if (l >= gl && r <= gr) return sum[x]; pushdown(x, l, r); ll res = 0; ll mid = (l + r) / 2; if (gl <= mid) res += get_sum(x << 1, l, mid, gl, gr); if (gr > mid) res += get_sum(x << 1 | 1, mid + 1, r, gl, gr); return res; } \u4e58\u6cd5\u7ebf\u6bb5\u6811 \u6839\u53f7\u7ebf\u6bb5\u6811","title":"\u7ebf\u6bb5\u6811"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_4","text":"int fa[MAXN]; //\u521d\u59cb\u5316 void init(int n){ for(int i = 0; i < n; i++) fa[i] = i; //\u7236\u7ed3\u70b9\u662f\u81ea\u5df1 } //\u67e5\u8be2\u5e76\u8def\u5f84\u538b\u7f29 int find(int x){ if(fa[x] != x) fa[x] = find(fa[x]); return fa[x]; } //\u5408\u5e76 void unite(int x, int y){ int fx = find(x); int fy = find(y); fa[fx] = fy; } //\u67e5\u8be2\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u96c6\u5408 bool same(int x, int y){ return find(x) == find(y); } \u5e26\u6743\u5e76\u67e5\u96c6 int fa[MAXN], value[MAXN]; //\u7236\u7ed3\u70b9 \u6743\u503c //\u67e5\u8be2 int find(int x){ if(x != fa[x]){ int t = fa[x]; fa[x] = find(fa[x]); value[x] += value[t]; //\u8fd9\u65f6\u7684\u7236\u4eb2\u7ed3\u70b9\u7684\u6743\u503c\u662f\u7236\u7ed3\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u6743\u503c //\u6240\u4ee5\u52a0\u4e0a\u539f\u672c\u81ea\u5df1\u5230\u7236\u7ed3\u70b9\u7684\u6743\u503c\u5c31\u662f\u81ea\u5df1\u5230\u6839\u7ed3\u70b9\u7684\u6743\u503c } return fa[x]; } //\u5408\u5e76, s\u662fx->y\u7684\u6743\u503c void unite(int x, int y, int s){ int px = find(x); int py = find(y); if(px != py){ fa[px] = py; value[px] = s+value[y]-value[x]; //x->y->py\u7684\u6743\u503c = x->px->py\u7684\u6743\u503c\uff0c\u6240\u4ee5\u5f97px->py\u7684\u6743\u503c\u4e3a\u4e0a\u5f0f } }","title":"\u5e76\u67e5\u96c6"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_5","text":"","title":"\u6808"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_6","text":"//\u6c42\u51fa\u6bcf\u4e2a\u5143\u7d20\u5de6\u53f3\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u5b83\u7684\u5143\u7d20\u7684\u4e0b\u6807 for(int i = 1; i <= n; i++) { while(!st.empty() && num[st.top()] > num[i]) { r[st.top()] = i; st.pop(); } if(st.empty()) l[i] = -1; else if(num[st.top()] == num[i]) l[i] = l[st.top()]; else l[i] = st.top(); st.push(i); } while(!st.empty()) { r[st.top()] = n+1; st.pop(); }","title":"\u5355\u8c03\u6808"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_7","text":"","title":"\u53ef\u6301\u4e45\u5316\u6570\u636e\u7ed3\u6784"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_8","text":"\u6d1b\u8c37 P3834 //\u4e00\u822c\u5f0032\u500d\u7a7a\u95f4 const int maxn = 2e5 + 5; int a[maxn], b[maxn], n, m, tot, q; int lc[maxn << 5], rc[maxn << 5], sum[maxn << 5], rt[maxn << 5]; void build(int &rt, int l, int r) { rt = ++tot, sum[rt] = 0; if (l == r) return; int mid = (l + r) >> 1; build(lc[rt], l, mid), build(rc[rt], mid + 1, r); } int update(int x, int l, int r, int t) { int xx = ++tot; lc[xx] = lc[x], rc[xx] = rc[x], sum[xx] = sum[x] + 1; if (l == r) return xx; int mid = (l + r) >> 1; if (t <= mid) lc[xx] = update(lc[xx], l, mid, t); else rc[xx] = update(rc[xx], mid + 1, r, t); return xx; } int query(int u, int v, int l, int r, int k) { int mid = (l + r) >> 1, t = sum[lc[v]] - sum[lc[u]]; if (l == r) return l; if (k <= t) return query(lc[u], lc[v], l, mid, k); else return query(rc[u], rc[v], mid + 1, r, k - t); } int main() { cin >> n >> m; for (int i = 1; i <= m; i++) scanf(\"%d\", a + i), b[i] = a[i]; sort(b + 1, b + 1 + n); q = unique(b + 1, b + 1 + n) - b - 1; build(rt[0], 1, q); for (int i = 1; i <= n; i++) { int t = lower_bound(b + 1, b + 1 + q, a[i]) - b; rt[i] = update(rt[i - 1], 1, q, t); } int l, r, k; for (int i = 1; i <= m; i++) { scanf(\"%d %d %d\", &l, &r, &k); printf(\"%d\\n\", b[query(rt[l - 1], rt[r], 1, q, k)]); } return 0; }","title":"\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811(\u4e3b\u5e2d\u6811)"},{"location":"OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#_9","text":"//\u9884\u5904\u7406 for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j]; //x1, y1, x2, y2 (\u67e5\u8be2\u533a\u95f4) int res = dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1];","title":"\u4e8c\u4f4d\u524d\u7f00\u548c"},{"location":"OI/%E6%95%B0%E8%AE%BA/","text":"1 \u6570\u8bba 1.1 \u57fa\u7840\u51fd\u6570 1.1.1 gcd \u8bbe \\(a/b=d, a\\%b=r\\) \u5373 \\(a=b\\times d+r\\) \uff0c\u6240\u4ee5 \\(gcd(b, r) | a\\) \uff0c\u53c8 \\(gcd(b, r) | b\\) \uff0c\u6240\u4ee5 \\(gcd(b, r) | gcd(a, b)\\) \u53c8 \\(r=a-b\\times d\\) \uff0c\u6240\u4ee5 \\(gcd(a, b) | r\\) \uff0c\u53c8 \\(gcd(a, b) | b\\) \uff0c\u6240\u4ee5 \\(gcd(a, b) | gcd(b, r)\\) \u6240\u4ee5 \\(gcd(a, b) = gcd(b, r)\\) , \u5373 \\(gcd(a, b) = gcd(b, a\\%b)\\) \u4e00\u4e9b\u6027\u8d28 \\(gcd(a,b)=gcd(a,a+b)=gcd(a,ka+b)\\) \\(gcd(ka,kb)=k*gcd(a,b)\\) \\(gcd(a,b,c)=gcd(gcd(a,b),c)\\) int gcd(int a, int b){ return b ? gcd(b, a%b) : a; } 1.1.2 lcm int lcm(int a, int b){ return a*b/gcd(a, b); } 1.1.3 exgcd \u6c42 \\(ax + by = gcd(a, b)\\) \u7684\u4e00\u7ec4\u6574\u6570\u89e3 x\uff0cy b = 0\u65f6\uff0c \\(gcd(a, b) = a\\) , x=1\u200b, y=0 \u4e3a\u4e00\u7ec4\u89e3 b != 0 \u65f6, \u8bbe \\(ax_{1} + by_{1} = gcd(a, b)\\) \u200b \\(bx_{2}+ (a\\%b)y_{2} = gcd(b, a\\%b)\\) \u200b \u56e0\u4e3a \\(gcd(a, b) = gcd(b, a\\%b)\\) \u200b \u6240\u4ee5 \\(bx_{2} + (a\\%b)y_{2} = ax_{1} + by_{1}\\) \u200b \\(a\\%b = a-(a/b)*b\\) , \u4ee3\u5165\u4e0a\u5f0f\u5f97 \u200b \\(bx_{2}+ ( a - (a/b) * b)*y_{2} = ax_{1} + by_{1}\\) \u200b \\(ay_{2} + bx_{2~}- (a/b)*by_{2} = ax_{1} + by_{1}\\) \u200b \\(ay_{2} + b[x_{2}-(a/b)*y_{2}] = ax_{1} + by_{1}\\) \u200b \u6240\u4ee5 \\(x_{1} = y_{2}\\) \u200b \\(y_{1} = x_{2} - (a/b)*y_{2}\\) ll exgcd(ll a, ll b, ll &x, ll &y) { //\u8fd4\u56de gcd(a, b) if(!b){ x = 1, y = 0; return a; } ll d = exgcd(b, a%b, x, y); ll t = x; x = y; y = t-(a/b)*y; return d; } 1.1.4 \u5feb\u901f\u5e42 typedef long long ll; ll pow(ll a, ll b, ll p) {// a^b (mod p) ll res = 1; while(b){ if(b&1) res = res*a%p; a = a*a%p; b >>= 1; } return res; } 1.1.5 \u5feb\u901f\u4e58 //\u9632\u6b62\u4e58\u6cd5\u7206ll ll mul(ll a, ll b, ll p){ ll res = 0; while(b){ if(b&1) res = (res + a) % p; a = (a + a) % p; b >>= 1; } return res; } 1.2 \u7d20\u6570 bool isprime(int x){ if(x <= 1) return false; for(int i = 2; i <= x/i; i++) if(x % i == 0) return false; return true; } 1.2.1 \u57c3\u6c0f\u7b5b\u7d20\u6570 bool isprime[N+1]; //0 1 \u662f\u975e\u7d20\u6570 void getPrime(){ for(int i = 2, i <= N; i++) isprime[i] = true; for(int i = 2; i <= N/i; i++) //\u5982\u679c x>sqrt(N) \u662f\u5408\u6570\uff0c \u5728\u524d\u9762\u5c31\u4f1a\u88ab\u7b5b\u6389 if(isprime[i]) for(int j = i*i; j <= N; j += i) //2i, 3i, 5i \u90fd\u5df2\u7ecf\u7b5b\u8fc7\uff0c\u53ef\u4ee5\u4ecei*i\u5f00\u59cb isprime[i] = false; } 1.2.2 \u6b27\u62c9\u7b5b\u7d20\u6570(\u7ebf\u6027\u7b5b) \\(O(n)\\) int cnt = 0; int prime[N+1]; //\u8bb0\u5f55\u7d20\u6570 bool isprime[N+1]; void euler(){ for(int i = 2; i <= N; i++) isprime[i] = true; for(int i = 2; i <= N; i++){ if(isprime[i]) prime[cnt++] = i; //\u8bb0\u5f55 for(int j = 0; j < cnt && i * prime[j] <= N; j++){ isprime[i*prime[j]] = false; if(i%prime[j] == 0) break; //\u4fdd\u8bc1\u5408\u6570\u88ab\u6700\u5c0f\u7684\u8d28\u56e0\u5b50\u7b5b\u53bb } } } 1.2.3 \u7b5b\u533a\u95f4\u5185\u7d20\u6570 //\u7b5b[l, r)\u4e4b\u95f4\u7684\u7d20\u6570 //\u6ce8\u610f\u533a\u95f4\u5f00\u95ed //\u5982\u679cl==1,l++\uff0c\u5426\u5219\u4f1a\u8ba4\u4e3a1\u662f\u7d20\u6570 bool isprime_small[MAXN]; //\u8bb0\u5f55\u524d sqrt(r) \u7684\u7d20\u6570 bool isprime[MAXN]; //\u5982\u679ci\u662f\u7d20\u6570\uff0c\u8bb0isprime[i-l] = true void segement_prime(ll l, ll r){ for(ll i = 0; i*i < r; i++) isprime_small[i] = true; for(ll i = 0; i < r-l; i++) isprime[i] = true; for(ll i = 2; i*i < r; i++) if(isprime_small[i]) { //\u5982\u679c\u662f\u7d20\u6570 for(ll j = i*i; j*j < r; j += i) //\u7b5b[2, sqrt(b)] isprime_small[j] = false; for(ll j = max(2LL, (l+i-1)/i)*i; j < r; j += i) //\u7b5b[a, b] isprime[j-l] = false; } } 1.2.4 Miller-Rabin \u7d20\u6027\u6d4b\u8bd5 bool check(ll a, ll r, ll t, ll n) { ll ret = pow(a, r, n), last = ret; for (int i = 0; i < t; i++) { ret = mul(ret, ret, n); if (ret == 1 && last != 1 && last != n - 1) return true; last = ret; } return ret != 1; } bool Miller_Rabin(ll n) { if (n == 2) return true; if (n < 2 || !(n & 1)) return false; ll r = n - 1, t = 0; while (!(r & 1)) r >>= 1, t++; for (int i = 1, j; i <= 8; i++) { ll a = rand() % (n - 2) + 2; if (check(a, r, t, n)) return false; } return true; } 1.2.5 Pollard-Rho\u5927\u6570\u5206\u89e3 ll pollard(ll n) { if (!(n & 1)) return 2; ll c = rand() % (n - 1) + 1; ll x = rand() % (n - 1) + 1, y = x, i = 1, k = 2; while (true) { i++; x = (mul(x, x, n) + c) % n; ll d = gcd(y - x + n, n); if (d != 1 && d != n) return d; if (y == x) return n; if (i == k) { y = x; k <<= 1; } } } /* \u500d\u589e\u4f18\u5316 ll pr(ll n) { ll x = 0, y = 0; ll c = 1ll * rand() % (n - 1) + 1; int step = 0, goal = 1; ll val = 1; for (goal = 1;; goal <<= 1, y = x, val = 1) { for (step = 1; step <= goal; ++step) { x = (mul(x, x, n) + c) % n; val = mul(val, abs(y - x), n); if ((step % 127) == 0) { ll d = gcd(val, n); if (d > 1) return d; } } ll d = gcd(val, n); if (d > 1) return d; } } */ ll fac[10000]; ll tot = 0; void find_fac(ll n) { if (Miller_Rabin(n)) { fac[tot++] = n; return; } ll p = n; while (p >= n) p = pollard(p); find_fac(p), find_fac(n / p); } 1.3 \u6b27\u62c9\u51fd\u6570 \u5b9a\u4e49: \\(\\varphi(n)\\) \u8868\u793a\u5c0f\u4e8e\u7b49\u4e8en \u4e14\u4e0e n \u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\uff0c\u6bd4\u5982 \\(\\varphi(1)=1\\) \u901a\u5f0f\uff1a \\(\\varphi(x)=x\\prod_{i=1}^n{(1-\\frac{1}{p_i})}\\) \uff0c\u5176\u4e2d \\(p_i\\) \u662f \\(x\\) \u7684\u6240\u6709\u8d28\u56e0\u6570 1.3.1 \u57fa\u672c\u6027\u8d28 \\(n\\) \u662f\u8d28\u6570\u65f6\uff0c \\(\\varphi(n)=n-1\\) \\(p\\) \u662f\u8d28\u6570\u65f6\uff0c \\(\\varphi(p^k)=(p-1)\\times p^{k-1}\\) \u79ef\u6027\u6027\u8d28\uff0c\u5982\u679c \\(gcd(a,b)=1\\) \uff0c\u5219 \\(\\varphi(a\\times b)=\\varphi(a)\\times \\varphi(b)\\) \u7279\u522b\u7684\uff0c \\(n\\) \u662f\u5947\u6570\u65f6\uff0c \\(\\varphi(2n)=\\varphi(n)\\) \\(n > 2\\) \u65f6\uff0c \\(\\varphi(n)\\) \u4e3a\u5076\u6570 \\(n=\\sum_{d|n}\\varphi(d)\\) \u6b27\u62c9\u5b9a\u7406\uff0c\u82e5 \\(gcd(a,m)=1\\) \uff0c\u5219 \\(a^{\\varphi(m)}\\equiv 1(mod \\quad m)\\) \u6269\u5c55\u6b27\u62c9\u5b9a\u7406 $$ a^b\\equiv \\begin{cases} a^{b \\% \\varphi(p)},\\quad\\quad\\quad gcd(a,p)=1 \\ a^b,\\quad \\quad \\quad \\quad \\quad gcd(a,p)\\neq1,b<\\varphi(p) \\quad\\quad (mod\\quad p) \\ a^{b \\% \\varphi(p)+\\varphi(p)},\\quad gcd(a,p)\\neq1,b\\geq\\varphi(p) \\end{cases} $$ 1.3.2 \u6c42\u5355\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570 \\[O(\\sqrt{n})\\] ll phi(ll n){ ll res = n; for(ll i = 2; i*i <= n; i++){ if(n%i==0){ res -= res/i; while(n%i==0) n/=i; } } if(n > 1) res -= res/n; return res; } 1.3.3\u57c3\u6c0f\u6c42\u6b27\u62c9\u51fd\u6570 \\(\\varphi(x)=x\\prod_{i=1}^n{(1-\\frac{1}{p_i})}\\) void euler(int n){ for (int i=1; i<=n; i++) phi[i] = i; for (int i=2; i<=n; i++) if (phi[i] == i)//\u8fd9\u4ee3\u8868i\u662f\u8d28\u6570 for (int j=i; j<=n; j += i) phi[j] = phi[j]/i*(i-1);//\u628ai\u7684\u500d\u6570\u66f4\u65b0\u6389 } 1.3.4\u6b27\u62c9\u7b5b\u6c42\u6b27\u62c9\u51fd\u6570 \\(if(i\\%prime[j] != 0)\\) \uff0c\u5219 \\(i\\) \u4e0e \\(prime[j]\\) \u4e92\u8d28 \u7531\u79ef\u6027\u6027\u8d28\u53ef\u5f97\uff0c \\(phi[i*prime[j]] = phi[i]*phi[prime[j]]\\) \\(if(i\\%prime[j] == 0)\\) \uff0c\u5219 i \u4e2d\u6709 i*prime[j] \u7684\u6240\u6709\u8d28\u56e0\u5b50\uff0c\u6709 \\(\\varphi(i*prime[j])=prime[j]*i*\\prod_{k=1}^n{(1-\\frac{1}{k_i})}=\\varphi(i)*prime[j]\\) int prime[maxn], cnt = 0; bool vis[maxn]; void euler(int n){ phi[1]=1; //1\u8981\u7279\u5224 for (int i=2; i < =n; i++){ if (vis[i] == 0){ //i\u662f\u8d28\u6570 prime[cnt++] = i; phi[i] = i-1; } for (int j=1; j < cnt && prime[j]*i <= n; j++){ vis[i*prime[j]] = 1; if (i%prime[j] == 0){ phi[i*prime[j]] = phi[i]*prime[j];//\u82e5prime[j]\u662fi\u7684\u8d28\u56e0\u5b50\uff0c\u5219\u6839\u636e\u8ba1\u7b97\u516c\u5f0f\uff0ci\u5df2\u7ecf\u5305\u62eci*prime[j]\u7684\u6240\u6709\u8d28\u56e0\u5b50 break;//\u4fdd\u8bc1\u6bcf\u4e2a\u6570\u53ea\u4f1a\u88ab\u81ea\u5df1\u6700\u5c0f\u7684\u56e0\u5b50\u7b5b\u6389\u4e00\u6b21 } else phi[i*prime[j]] = phi[i]*phi[prime[j]];//\u79ef\u6027\u51fd\u6570\u7684\u6027\u8d28 } } } 1.4 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 1.4.1 CRT \u6d1b\u8c37 P3868 $X \u2261 r_{i} ( mod\\quad m_{i} ) $ \u8981\u6c42\uff1am~i~ \u4e24\u4e24\u4e92\u8d28 ll CRT(ll n, ll *r, ll *m){ ll res = 0, M = 1; for(int i = 0; i < n; i++) M *= m[i]; for(int i = 0; i < n; i++) { ll x, y; ll tmp = M / m[i]; ll d = exgcd(tmp, m[i], x, y); //gcd(tmp, m[i]) = 1 x = (x%m[i]+m[i])%m[i]; res = (res + tmp*x*r[i]) % M; //\u53ef\u80fd\u9700\u8981\u7528\u5230\u5feb\u901f\u4e58\u9632\u6b62\u6ea2\u51fa } return (res + M) % M; } 1.4.2 EXCRT \u6d1b\u8c37 P4777 \\(X \u2261 r_{i} ( mod\\quad m_{i} )\\) \u4e0d\u8981\u6c42 m~i~ \u4e24\u4e24\u4e92\u8d28 \u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u7684\u89e3\u4e3a r~1~ \u5047\u8bbe\u6ee1\u8db3\u524d k-1 \u4e2a\u6761\u4ef6\u7684\u4e00\u4e2a\u7279\u89e3\u4e3a res\uff0c M~k-1~ \u4e3a\u524d k-1 \u4e2a m \u7684 lcm \u5219\u524d k-1 \u4e2a\u65b9\u7a0b\u7684\u901a\u89e3\u4e3a $$ res+x\\times M_{k-1} $$ \u90a3\u4e48\u5bf9\u4e8e\u524d k \u4e2a\u65b9\u7a0b,\u5982\u679c\u6709\u89e3\uff0c\u5219 \u5b58\u5728\u6574\u6570 x\uff0c\u4f7f $$ res+x\\times M_{k-1}\\equiv r_k\\quad (mod\\quad m_k) $$ \u5373 $$ x\\times M_{k-1}\\equiv r_k-res\\quad (mod\\quad m_k) $$ \u5229\u7528\u62d3\u6b27\u6c42\u89e3\u5f97 x\uff0c\u5219\u524d k \u4e2a\u65b9\u7a0b\u7684\u4e00\u4e2a\u7279\u89e3\u4e3a $$ res+x\\times M_{k-1} $$ \u901a\u89e3\u4e3a $ \u7279\u89e3 + x^{'}M_k$ ll EXCRT(ll n, ll *r, ll *m){ ll res = r[0], M = m[0]; ll x, y; for(int i = 1; i < n; i++) { ll c = (r[i] - res%m[i] +m[i]) % m[i]; ll d = exgcd(M, m[i], x, y), bg = m[i]/d; x = (x%bg+bg)%bg; if(c%d != 0) return -1; //\u65e0\u89e3,\u56e0\u4e3a\u65e0\u6cd5\u8ba9\u4f59\u6570\u6269\u5927\u6210c x = mul(x, c/d, bg); //\u5feb\u901f\u4e58 res += x*M; M *= bg; //lcm res = (res%M+M)%M; } return res; } 1.5 \u540c\u4f59\u95ee\u9898 1.5.1 \u9006\u5143 \u540c\u4f59\u4e0d\u6ee1\u8db3\u9664\u6cd5\uff0c \\(a/b\\quad mod \\quad p\\quad != (a\\quad mod\\quad p)/(b\\quad mod\\quad p)\\) \u5f15\u5165 b \u7684\u9006\u5143 x, \u5373 \\(b*x = 1 (mod\\quad p)\\) \uff0cb \u4e0e p \u4e92\u8d28 \u5047\u8bbe $ a/b = k (mod\\quad p)$ \u540c\u4e58 bx \u5f97 $ a/b * bx = k * 1\uff08mod\\quad p)$ \u200b \\(a*x = k (mod\\quad p)\\) \u6ce8\u610f\uff1a b \u548c p \u4e92\u8d28\uff0cb \u624d\u6709\u5173\u4e8e p \u7684\u9006\u5143 1.5.2 \u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143 \u8d39\u9a6c\u5c0f\u5b9a\u7406 \uff1a\u5982\u679cp\u4e3a\u8d28\u6570\uff0c\u4e14 a \u4e0e p \u4e92\u8d28(\u5373 a \u4e0d\u662f p \u7684\u500d\u6570)\uff0c\u5219 \\(a^{p-1} \\equiv 1 \uff08mod\\quad p)\\) \u6240\u4ee5\u6709 \\(a * a^{p-2} \\equiv 1 (mod\\quad p)\\) , \u5373 \\(a^{p-2} (mod\\quad p)\\) \u662f a \u7684\u9006\u5143 //\u7528\u5feb\u901f\u5e42 ll pow(ll a, ll p){ int res = 1; int d = p-2; while(d) { if(d&1) res = res*a%p; a = a*a%p; d >>= 1; } return res; } 1.5.3 \u62d3\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143 \u5982\u679cb \u4e0e p \u4e92\u8d28\uff0c\u5373 \\(gcd(b, p) = 1\\) \u8981\u89e3 \\(b*x = 1 (mod\\quad p)\\) , \u5373\u6c42 \\(bx + yp = 1 = gcd(b, p)\\) \u7684\u89e3 x ll inv(ll b, ll p) { ll x, y; ll d = exgcd(b, p, x, y); return d == 1 ? (x+p)%p : -1; //\u8fd4\u56de -1 \u8bf4\u660e b,p \u4e0d\u4e92\u8d28 } 1.5.4 \u6b27\u62c9\u51fd\u6570\u6c42\u9006\u5143 \u6d1b\u8c37 P3811 \u662f\u8d39\u5c0f\u7684\u63a8\u5e7f\uff0c\u4e0d\u8981\u6c42 p \u4e3a\u8d28\u6570\uff0c\u4f46 \\( \\(gcd(a,p)=1\\) \\) \\[a^{\\varphi(p)}\\equiv1(mod\\quad p)$$\uff0c\u6240\u4ee5\u5176\u9006\u5143\u4e3a $$a^{\\varphi(n)-1}\\] ll phi(ll n){ ll res = n; for(ll i = 2; i*i <= n; i++) { if(n%i==0) { res -= res/i; while(n%i==0) n/=i; } } if(n > 1) res -= res/n; return res; } ans = pow(a, phi(p)-1,p); 1.5.5 \u9636\u4e58\u9006\u5143 \u6c42\u9636\u4e58\u7684\u9006\u5143\uff0c\u5148\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u51fa n! \u5728 p \u4e0b\u7684\u9006\u5143\uff0c\u518d\u5f80\u524d\u63a8 \u5047\u8bbe n! \u7684\u9006\u5143\u4e3a [n!]^-1^, \u8981\u6c42 (n-1)! \u7684\u9006\u5143 $$ (n-1)! \\times n[n!]^{-1} \u2261 1 (mod\\quad p) $$ \u6240\u4ee5\uff0c(n-1)! \u7684\u9006\u5143\u5c31\u662f n[n!] -1 void fa_inv(ll n, ll p){ fact[0] = 1; //factorial for(int i = 1; i <= n; i++) fact[i] = fact[i-1]*i % p; finv[N] = pow(fact[n], p-2, p); for(int i = n-1; i >= 0; i--) finv[i] = (i+1)*finv[i+1]%p; } 1.5.6 \u7ebf\u6027\u6c42\u9006\u5143(\u6253\u8868) \u6d1b\u8c37 P3811 \u8981\u6c42\u51fa 1-n \u4e2d\u6240\u6709\u6570\u5bf9 p \u7684\u9006\u5143\uff0c\u9009\u62e9\u6253\u8868 \u200b \\(1^{\u22121} \u2261 1 (mod\\quad p)\\) \u8bbe \\(p = k * i + r\\) \u5176\u4e2d 1 < r < i < p, \u5373 \\(k = p/i, r = p\\quad mod\\quad i\\) \u6240\u4ee5\u6709 \\(k * i + r \u2261 0 ( mod\\quad p )\\) \u4e24\u8fb9\u540c\u65f6\u4e58\u4e0a \\(i^{\u22121} * r^{\u22121}\\) \u5f97 $k * r^{\u22121} + i^{\u22121} \u2261 0 ( mod\\quad p ) $ \u200b \\(i^{\u22121} \u2261 \u2212k * r^{\u22121} ( mod\\quad p )\\) \u5f97\u9012\u63a8\u516c\u5f0f \\(i^{-1} \u2261 -\uff08p/i) * (p\\quad mod\\quad i)^{-1} (mod\\quad p)\\) \u6574\u7406\u5f97 \\(inv[i] = (p - p/i) * inv[p\\%i] \\% p\\) \u5176\u4e2d p % i \u6bd4 i \u5c0f void inverse=-(int n, int p) { inv[1] = 1; for(int i = 2; i <= n; i++) inv[i] = (ll)(p - p/i) * inv[p%i] % p; } 1.5.7 Lucas\u5b9a\u7406 \u6d1b\u8c37 P3807 HDU 3037 \u89e3\u51b3\u7ec4\u5408\u6570\u53d6\u4f59\u7684\u95ee\u9898\uff1a (p\u5fc5\u987b\u662f\u7d20\u6570,\u4e0d\u7136\u4e0d\u80fd\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143) $$ C(n,m) = \\prod_{i=0}^{k}{C(n_i, m_i)}(mod\\quad p) $$ \\[ n = n_k p^k+n_{k-1} p^{k-1}+\\cdots+n_1p+n_0 \\] \\[ m=m_k p^k+m_{k-1} p^{k-1}+\\cdots+m_1p+m_0 \\] //\u9884\u5904\u7406\u9636\u4e58 void getFact(ll p) { fact[0] = 1; for(ll i = 1; i <= p; i++) f[i] = f[i-1]*i%p; } //\u8ba1\u7b97\u7ec4\u5408\u6570 ll comb(ll n, ll m, ll p) { if(m>n) return 0; return fact[n]*pow(f[m],p-2, p)%p*pow(f[n-m], p-2, p)%p; //\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143 } ll lucas(ll n, ll m, ll p) { if(!m) return 1; return lucas(n/p, m/p, p)%p*comb(n%p, m%p, p)%p; } 1.5.8 *\u62d3\u5c55Lucas \u6d1b\u8c37 P4720 \u89e3\u51b3 p \u662f\u975e\u7d20\u6570\u65f6\u7684\u7ec4\u5408\u6570\u53d6\u4f59\u95ee\u9898 https://blog.csdn.net/qq_30115697/article/details/88942177 https://www.luogu.com.cn/problem/solution/P4720 typedef long long ll; #define N 100 ll n, m, p; ll exgcd(ll a, ll b, ll &x, ll &y) //\u62d3\u6b27 { if(!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a%b, x, y); ll t = x; x = y; y = t-a/b*y; return d; } ll pow(ll a, ll b, ll p) //\u5feb\u901f\u5e42 { ll res = 1; while(b) { if(b&1) res = (res*a)%p; a = (a*a)%p; b >>= 1; } return res; } ll fact(ll n, ll pi, ll pk) //pk = pi^a \u6c42\u9636\u4e58\uff0c\u7ed3\u679c\u662fn!\u53bb\u6389\u6240\u6709 pi \u56e0\u5b50 { if(!n) return 1; //0! = 0 ll res = 1; for(ll i = 2; i <= pk; i++) //\u5904\u7406\u5faa\u73af\u8282\u5185\u7684\u6570\u5b57 if(i%pi) res = (res*i)%pk; res = pow(res, n/pk, pk); //\u6240\u6709\u5faa\u73af\u8282\u7684\u4e58\u79ef for(ll i = 2; i <= n%pk; i++) //\u5355\u72ec\u9879 if(i%pi) res = (res*i)%pk; return ans*fac(n/pi, pi, pk)%pk; } inline ll inv(ll n, ll mod) { ll x, y; exgcd(n, mod, x, y); return (x%mod+mod)%mod; } inline crt(ll b, ll mod) { return b*inv(p/mod, mod)%p*(p/mod)%p; //\u4f59\u6570\u4e3a 1 } inline ll comb(ll n, ll m, ll pi, ll pk) { ll up = fact(n, pi, pk); ll d1 = fact(m, pi, pk); ll d2 = fact(n-m, pi, pk); ll cnt = 0; for(ll i = p; i <= n; i *= pi) cnt += n/i; for(ll i = p; i <= m; i *= pi) cnt -= m/i; for(ll i = p; i <= n-m; i *= pi) cnt -= (n-m)/i; return up*inv(d1, pk)%pk*inv(d2, pk)%pk*pow(pi, cnt, pk)%pk; } ll exLucas(ll n, ll m) { ll res = 0, tmp = p, pk; for(ll i = 2; i*i <= p; i++) if(tmp % i == 0) { pk = 1; while(tmp%i==0) } } int main() { cin >> n >> m >> p; cout << exLucas(n, m); return 0; } 1.5.9 BSGS \u6c42 \\(a^x=b(mod\\ \\ p)\\) \u7684 x \u6700\u5c0f\u7684\u89e3 ll bsgs(ll a, ll b, ll p) { map<ll, ll> hash; hash.clear(); b %= p; ll t = sqrt(p) + 1; for (ll i = 0; i < t; i++) hash[b * ksm(a, i, p) % p] = i; a = ksm(a, t, p); if (!a) return b == 0 ? 1 : -1; for (ll i = 1; i <= t; i++) { ll val = ksm(a, i, p); int j = hash.find(val) == hash.end() ? -1 : hash[val]; if (j >= 0 && i * t - j >= 0) return i * t - j; } return -1; //\u65e0\u89e3 } 1.8 \u6570\u503c\u5206\u6790 1.8.1 Simpson \u516c\u5f0f \u5982\u679c\u539f\u51fd\u6570\u662f\u6b21\u6570\u4e0d\u8d85\u8fc7\u4e8c\u6b21\u7684\u591a\u9879\u5f0f\uff0c\u53ef\u4ee5\u7cbe\u786e\u8ba1\u7b97\u79ef\u5206\u503c\uff0c\u53ea\u9700\u8981\u77e5\u9053\u7aef\u70b9\u548c\u4e2d\u70b9\u7684\u503c $$ \\int_{a}^{b}{f(x)}dx \\approx \\frac{b-a}{6}(\\quad f(a)+4f(\\frac{a+b}{2})+f(b)\\quad) $$ 1.8.2 \u9ad8\u65af\u7ea6\u65e6\u6d88\u5143 \u6d1b\u8c37 P3389 \\( \\(O(n^3)\\) \\) \uff0c\u65b9\u7a0b\u6570\u548c\u672a\u77e5\u6570\u90fd\u8981\u6c42\u662fn\uff0c\u7ed3\u679c\u5728 a [i] [n+1]\u4e2d\uff0c\u8fd4\u56de\u503c1\u8868\u793a\u6709\u552f\u4e00\u89e3\uff0c0\u8868\u793a\u65e0\u89e3 const double eps = 1e-8; int guass_jordan(int n) { for(int i = 1; i <= n; i++) { int r = i; for(int j = i; j <= n; j++)//\u628a\u6b63\u5728\u5904\u7406\u7684\u672a\u77e5\u6570\u7cfb\u6570\u7edd\u5bf9\u503c\u6700\u5927\u7684\u653e\u4e0a\u6765 if(fabs(a[r][i]) < fabs(a[j][i])) r = j; if(r != i) //\u4ea4\u6362 for(int j = 1; j <= n+1; j++) swap(a[i][j], a[r][j]); if(fabs(a[i][i]) < eps) return 0; //\u65e0\u89e3 for(int j = i+1; j <= n+1; j++) a[i][j] /= a[i][i]; //\u7cfb\u6570\u5316\u4e3a1,\u6ce8\u610fi+1\uff0c\u5982\u679c\u4ecei\u5f00\u59cb\u4f1a\u5f71\u54cd\u5230\u540e\u9762 for(int j = 1; j <= n; j++) if(j != i) for(int k = i+1; k <= n+1; k++) //\u6ce8\u610fi+1\uff0c\u5982\u679c\u4ecei\u5f00\u59cb\u4f1a\u5f71\u54cd\u5230\u540e\u9762 a[j][k] -= a[i][k]*a[j][i]; } return 1; } \u5176\u4ed6 \u88f4\u8700\u5b9a\u7406 \u82e5 a,b \u662f\u6574\u6570,\u4e14 \\(gcd(a,b)=d\\) \uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u7684\u6574\u6570 x,y, \\(ax+by\\) \u90fd\u4e00\u5b9a\u662f d \u7684\u500d\u6570\uff0c\u5373 \\( \\(d|(ax+by)\\) \\) \u7279\u522b\u5730\uff0c\u4e00\u5b9a\u5b58\u5728\u6574\u6570x,y\uff0c\u4f7fax+by=d\u6210\u7acb\u3002 \u91cd\u8981\u63a8\u8bba\uff1aa,b\u4e92\u8d28\u7684\u5145\u8981\u6761\u4ef6\u662f\u5b58\u5728\u6574\u6570 x,y \u4f7f ax+by=1. \u552f\u4e00\u5206\u89e3\u5b9a\u7406 \u6b63\u6574\u6570 \\(N\\) \u7684\u6807\u51c6\u5206\u89e3\u5f0f\uff1a \\(N=p_1^{a_1}p_2^{a_2}...p_n^{a_n}\\) \u90a3 \\(N\\) \u7684\u6b63\u56e0\u6570\u4e2a\u6570\u4e3a \\(\\sigma_0(N)=(1+a_1)(1+a_2)...(1+a_n)\\) \u6240\u6709\u6b63\u56e0\u6570\u7684\u548c\u4e3a \\(\\sigma_1(N)=(1+p_1+p_1^2+...+p_1^{a_1})...(1+p_n+p_n^2+...+p_n^{a_n})\\) \u6574\u6570\u5206\u5757 \\(\\frac{n}{1}+\\frac{n}{2}+\\frac{n}{3}+..+\\frac{n}{n}\\) \u7684\u548c ll ans = 0; for (int l = 1, r; l <= n; l = r + 1) { r = n / (n / l); //\u6bcf\u6bb5\u533a\u95f4\u7684\u53f3\u7aef\u70b9 ans += (ll)(n / l) * (r - l + 1); } \u65af\u7279\u6797\u516c\u5f0f \\[ n! \\approx \\sqrt{2 \\pi n}(\\frac{n}{e})^n \\] \u7528 log10 \u5feb\u901f\u8ba1\u7b97\u5927\u6570\u7684\u4f4d\u6570 \u9519\u6392\u516c\u5f0f \\[ f(n) = (n-1)(f(n-1)f(n-2)) \\] \u5bb9\u65a5\u539f\u7406 HDU 4135 $$ |U(A_i)|=\\sum_{1\\leq i\\leq m}{|A_i|}-\\sum_{i\\leq i<j\\leq m}{|A_i\\bigcap A_j|}+ \\dots+(-1)^{m+1}\\sum|A_1\\bigcap A_2\\bigcap \\dots\\bigcap A_m| $$ void solve() { int res = 0; for(int i = 1; i < (1<<m); i++) { int cnt = 0; for(int j = i; j != 0; j >>= 1) cnt += j&1; ll lcm = 1; for(int j = 0; j < m; j++) { if( (i>>j) & 1) { lcm = lcm / gcd(lcm, num[j]) * num[j]; //eg,\u662f2\u7684\u500d\u6570\u4e0d\u4e00\u5b9a\u662f4\u7684\u500d\u6570 if(lcm > n) break; } } if(cnt % 2 == 0) res -= n/lcm; else res += n/lcm; } cout << res; } Catalan\u6570 \u8bbe h(n) \u8868\u793a Catalan\u6570\u7684\u7b2cn\u9879\uff0ch(0) = 1, h(1) = 1 \u9012\u63a8\u5f0f\uff1a \\(h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)(n\\geq2)\\) \u53e6\u7c7b\u9012\u63a8\u5f0f\uff1a \\(h(n)=h(n-1)*(4*n-2)/(n+1)\\) \u9012\u63a8\u5173\u7cfb\u7684\u89e3\uff1a \\(h(n)=C(2n,n)/(n+1)(n=0,1,2,...)\\) \u9012\u63a8\u5173\u7cfb\u7684\u53e6\u7c7b\u89e3\uff1a \\(h(n)=C(2n,n)-C(2n,n-1)(n=0,1,2,...)\\) eg\uff1a\u8fdb\u51fa\u6808\uff0c\u7535\u5f71\u8d2d\u7968\uff0c\u5706\u5185\u8fde\u5f26\uff0c\u51f8\u591a\u8fb9\u5f62\u7684\u5256\u5206\uff0cn\u5bf9\u62ec\u53f7\u5f62\u6210\u7684\u5408\u6cd5\u62ec\u53f7\u8868\u8fbe\u5f0f\u7684\u4e2a\u6570\uff0c n+1\u4e2a\u6570\u8fde\u4e58\u4e0d\u540c\u7684\u4e58\u6cd5\u987a\u5e8f\u6570\u3001 Bell\u6570\u548cStirling\u6570 \u7b2c\u4e00\u7c7b Stirling\u6570\u9012\u63a8\u5f0f\uff1a \\(S(i,j)=(i-1)*S(i-1,j)+S(i-1,j-1)\\) eg\uff1ai \u4e2a\u4e0d\u540c\u5143\u7d20\u6784\u6210 j \u4e2a\u5706\u6392\u5217\u7684\u6570\u76ee \u7b2c\u4e8c\u7c7b Stirling\u6570\u9012\u63a8\u5f0f\uff1a \\(S(i,j)=j*S(i-1,j)+S(i-1,j-1)\\) eg\uff1ai \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u5212\u5206\u4e3a j \u4e2a\u975e\u7a7a\u96c6\u7684\u65b9\u6cd5\u7684\u6570\u76ee Bell\u6570\u548c\u7b2c\u4e8c\u7c7bStirling\u6570\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a \\(B_n=\\sum_{k=1}^n{S(n,k)}\\) eg\uff1an \u4e2a\u4e0d\u540c\u7684\u6570\u7684\u5212\u5206\u65b9\u6848\u6570 \u6b27\u62c9\u51fd\u6570\u4e0e\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570* \u4e00\u4e2a\u6b27\u62c9\u51fd\u6570\u7684\u6027\u8d28\uff1a $$ m = \\sum_{d|m}{\\varphi(d)} $$ \u76f8\u4f3c\u5f62\u5f0f\u7684\u4e00\u4e2a\u91cd\u8981\u7ed3\u8bba\uff1a $$ g(m)=\\sum_{d|m}{f(d)} $$ \u5176\u4e2d\u5982\u679c f(d) \u8ba9 g(m) \u662f\u79ef\u6027\u51fd\u6570\uff0c\u90a3\u4e48 f(d) \u662f\u79ef\u6027\u51fd\u6570 \u53c8\u56e0\u4e3a m \u662f\u79ef\u6027\u7684\uff0c\u6240\u4ee5\u6b27\u62c9\u51fd\u6570 \\( \\(\\varphi(d)\\) \\) \u4e5f\u662f\u79ef\u6027\u7684\uff08\u6b27\u62c9\u51fd\u6570\u7684\u79ef\u6027\u5fc5\u987b\u4e24\u6570\u4e92\u8d28\uff09 \u6b27\u62c9\u51fd\u6570\u79ef\u6027\u7684\u8bc1\u660e\uff08\u4e24\u6570\u4e92\u8d28\uff09\uff1a \u56e0\u4e3a g(m) \u4e3a\u79ef\u6027 \u6269\u5c55\u5de6\u8fb9 \\( \\(g(m_1m_2)=\\sum_{d|m_1m_2}{f(d)}=\\sum_{d_1|m_1}\\sum_{d_2|m_2}f(d_1)f(d_2)\\) \\) \u6269\u5c55\u53f3\u8fb9 \\( \\(g(m_1)g(m_2)=\\sum_{d_1|m_1}f(d_1)\\sum_{d_2|m_2}{f(d_2)}\\) \\) \u200b \u6709 \\( \\(g(m_1m_2)=g(m_1)g(m_2)\\) \\) \u9006\u547d\u9898\u4e5f\u6210\u7acb\uff0c\u6240\u4ee5\u4e24\u6570\u4e92\u8d28\u65f6\u6b27\u62c9\u51fd\u6570\u6709\u79ef\u6027","title":"\u6570\u8bba"},{"location":"OI/%E6%95%B0%E8%AE%BA/#1","text":"","title":"1 \u6570\u8bba"},{"location":"OI/%E6%95%B0%E8%AE%BA/#11","text":"","title":"1.1 \u57fa\u7840\u51fd\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#111-gcd","text":"\u8bbe \\(a/b=d, a\\%b=r\\) \u5373 \\(a=b\\times d+r\\) \uff0c\u6240\u4ee5 \\(gcd(b, r) | a\\) \uff0c\u53c8 \\(gcd(b, r) | b\\) \uff0c\u6240\u4ee5 \\(gcd(b, r) | gcd(a, b)\\) \u53c8 \\(r=a-b\\times d\\) \uff0c\u6240\u4ee5 \\(gcd(a, b) | r\\) \uff0c\u53c8 \\(gcd(a, b) | b\\) \uff0c\u6240\u4ee5 \\(gcd(a, b) | gcd(b, r)\\) \u6240\u4ee5 \\(gcd(a, b) = gcd(b, r)\\) , \u5373 \\(gcd(a, b) = gcd(b, a\\%b)\\) \u4e00\u4e9b\u6027\u8d28 \\(gcd(a,b)=gcd(a,a+b)=gcd(a,ka+b)\\) \\(gcd(ka,kb)=k*gcd(a,b)\\) \\(gcd(a,b,c)=gcd(gcd(a,b),c)\\) int gcd(int a, int b){ return b ? gcd(b, a%b) : a; }","title":"1.1.1 gcd"},{"location":"OI/%E6%95%B0%E8%AE%BA/#112-lcm","text":"int lcm(int a, int b){ return a*b/gcd(a, b); }","title":"1.1.2 lcm"},{"location":"OI/%E6%95%B0%E8%AE%BA/#113-exgcd","text":"\u6c42 \\(ax + by = gcd(a, b)\\) \u7684\u4e00\u7ec4\u6574\u6570\u89e3 x\uff0cy b = 0\u65f6\uff0c \\(gcd(a, b) = a\\) , x=1\u200b, y=0 \u4e3a\u4e00\u7ec4\u89e3 b != 0 \u65f6, \u8bbe \\(ax_{1} + by_{1} = gcd(a, b)\\) \u200b \\(bx_{2}+ (a\\%b)y_{2} = gcd(b, a\\%b)\\) \u200b \u56e0\u4e3a \\(gcd(a, b) = gcd(b, a\\%b)\\) \u200b \u6240\u4ee5 \\(bx_{2} + (a\\%b)y_{2} = ax_{1} + by_{1}\\) \u200b \\(a\\%b = a-(a/b)*b\\) , \u4ee3\u5165\u4e0a\u5f0f\u5f97 \u200b \\(bx_{2}+ ( a - (a/b) * b)*y_{2} = ax_{1} + by_{1}\\) \u200b \\(ay_{2} + bx_{2~}- (a/b)*by_{2} = ax_{1} + by_{1}\\) \u200b \\(ay_{2} + b[x_{2}-(a/b)*y_{2}] = ax_{1} + by_{1}\\) \u200b \u6240\u4ee5 \\(x_{1} = y_{2}\\) \u200b \\(y_{1} = x_{2} - (a/b)*y_{2}\\) ll exgcd(ll a, ll b, ll &x, ll &y) { //\u8fd4\u56de gcd(a, b) if(!b){ x = 1, y = 0; return a; } ll d = exgcd(b, a%b, x, y); ll t = x; x = y; y = t-(a/b)*y; return d; }","title":"1.1.3 exgcd"},{"location":"OI/%E6%95%B0%E8%AE%BA/#114","text":"typedef long long ll; ll pow(ll a, ll b, ll p) {// a^b (mod p) ll res = 1; while(b){ if(b&1) res = res*a%p; a = a*a%p; b >>= 1; } return res; }","title":"1.1.4 \u5feb\u901f\u5e42"},{"location":"OI/%E6%95%B0%E8%AE%BA/#115","text":"//\u9632\u6b62\u4e58\u6cd5\u7206ll ll mul(ll a, ll b, ll p){ ll res = 0; while(b){ if(b&1) res = (res + a) % p; a = (a + a) % p; b >>= 1; } return res; }","title":"1.1.5 \u5feb\u901f\u4e58"},{"location":"OI/%E6%95%B0%E8%AE%BA/#12","text":"bool isprime(int x){ if(x <= 1) return false; for(int i = 2; i <= x/i; i++) if(x % i == 0) return false; return true; }","title":"1.2 \u7d20\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#121","text":"bool isprime[N+1]; //0 1 \u662f\u975e\u7d20\u6570 void getPrime(){ for(int i = 2, i <= N; i++) isprime[i] = true; for(int i = 2; i <= N/i; i++) //\u5982\u679c x>sqrt(N) \u662f\u5408\u6570\uff0c \u5728\u524d\u9762\u5c31\u4f1a\u88ab\u7b5b\u6389 if(isprime[i]) for(int j = i*i; j <= N; j += i) //2i, 3i, 5i \u90fd\u5df2\u7ecf\u7b5b\u8fc7\uff0c\u53ef\u4ee5\u4ecei*i\u5f00\u59cb isprime[i] = false; }","title":"1.2.1 \u57c3\u6c0f\u7b5b\u7d20\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#122","text":"\\(O(n)\\) int cnt = 0; int prime[N+1]; //\u8bb0\u5f55\u7d20\u6570 bool isprime[N+1]; void euler(){ for(int i = 2; i <= N; i++) isprime[i] = true; for(int i = 2; i <= N; i++){ if(isprime[i]) prime[cnt++] = i; //\u8bb0\u5f55 for(int j = 0; j < cnt && i * prime[j] <= N; j++){ isprime[i*prime[j]] = false; if(i%prime[j] == 0) break; //\u4fdd\u8bc1\u5408\u6570\u88ab\u6700\u5c0f\u7684\u8d28\u56e0\u5b50\u7b5b\u53bb } } }","title":"1.2.2 \u6b27\u62c9\u7b5b\u7d20\u6570(\u7ebf\u6027\u7b5b)"},{"location":"OI/%E6%95%B0%E8%AE%BA/#123","text":"//\u7b5b[l, r)\u4e4b\u95f4\u7684\u7d20\u6570 //\u6ce8\u610f\u533a\u95f4\u5f00\u95ed //\u5982\u679cl==1,l++\uff0c\u5426\u5219\u4f1a\u8ba4\u4e3a1\u662f\u7d20\u6570 bool isprime_small[MAXN]; //\u8bb0\u5f55\u524d sqrt(r) \u7684\u7d20\u6570 bool isprime[MAXN]; //\u5982\u679ci\u662f\u7d20\u6570\uff0c\u8bb0isprime[i-l] = true void segement_prime(ll l, ll r){ for(ll i = 0; i*i < r; i++) isprime_small[i] = true; for(ll i = 0; i < r-l; i++) isprime[i] = true; for(ll i = 2; i*i < r; i++) if(isprime_small[i]) { //\u5982\u679c\u662f\u7d20\u6570 for(ll j = i*i; j*j < r; j += i) //\u7b5b[2, sqrt(b)] isprime_small[j] = false; for(ll j = max(2LL, (l+i-1)/i)*i; j < r; j += i) //\u7b5b[a, b] isprime[j-l] = false; } }","title":"1.2.3 \u7b5b\u533a\u95f4\u5185\u7d20\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#124-miller-rabin","text":"bool check(ll a, ll r, ll t, ll n) { ll ret = pow(a, r, n), last = ret; for (int i = 0; i < t; i++) { ret = mul(ret, ret, n); if (ret == 1 && last != 1 && last != n - 1) return true; last = ret; } return ret != 1; } bool Miller_Rabin(ll n) { if (n == 2) return true; if (n < 2 || !(n & 1)) return false; ll r = n - 1, t = 0; while (!(r & 1)) r >>= 1, t++; for (int i = 1, j; i <= 8; i++) { ll a = rand() % (n - 2) + 2; if (check(a, r, t, n)) return false; } return true; }","title":"1.2.4 Miller-Rabin \u7d20\u6027\u6d4b\u8bd5"},{"location":"OI/%E6%95%B0%E8%AE%BA/#125-pollard-rho","text":"ll pollard(ll n) { if (!(n & 1)) return 2; ll c = rand() % (n - 1) + 1; ll x = rand() % (n - 1) + 1, y = x, i = 1, k = 2; while (true) { i++; x = (mul(x, x, n) + c) % n; ll d = gcd(y - x + n, n); if (d != 1 && d != n) return d; if (y == x) return n; if (i == k) { y = x; k <<= 1; } } } /* \u500d\u589e\u4f18\u5316 ll pr(ll n) { ll x = 0, y = 0; ll c = 1ll * rand() % (n - 1) + 1; int step = 0, goal = 1; ll val = 1; for (goal = 1;; goal <<= 1, y = x, val = 1) { for (step = 1; step <= goal; ++step) { x = (mul(x, x, n) + c) % n; val = mul(val, abs(y - x), n); if ((step % 127) == 0) { ll d = gcd(val, n); if (d > 1) return d; } } ll d = gcd(val, n); if (d > 1) return d; } } */ ll fac[10000]; ll tot = 0; void find_fac(ll n) { if (Miller_Rabin(n)) { fac[tot++] = n; return; } ll p = n; while (p >= n) p = pollard(p); find_fac(p), find_fac(n / p); }","title":"1.2.5 Pollard-Rho\u5927\u6570\u5206\u89e3"},{"location":"OI/%E6%95%B0%E8%AE%BA/#13","text":"\u5b9a\u4e49: \\(\\varphi(n)\\) \u8868\u793a\u5c0f\u4e8e\u7b49\u4e8en \u4e14\u4e0e n \u4e92\u8d28\u7684\u6570\u7684\u4e2a\u6570\uff0c\u6bd4\u5982 \\(\\varphi(1)=1\\) \u901a\u5f0f\uff1a \\(\\varphi(x)=x\\prod_{i=1}^n{(1-\\frac{1}{p_i})}\\) \uff0c\u5176\u4e2d \\(p_i\\) \u662f \\(x\\) \u7684\u6240\u6709\u8d28\u56e0\u6570","title":"1.3 \u6b27\u62c9\u51fd\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#131","text":"\\(n\\) \u662f\u8d28\u6570\u65f6\uff0c \\(\\varphi(n)=n-1\\) \\(p\\) \u662f\u8d28\u6570\u65f6\uff0c \\(\\varphi(p^k)=(p-1)\\times p^{k-1}\\) \u79ef\u6027\u6027\u8d28\uff0c\u5982\u679c \\(gcd(a,b)=1\\) \uff0c\u5219 \\(\\varphi(a\\times b)=\\varphi(a)\\times \\varphi(b)\\) \u7279\u522b\u7684\uff0c \\(n\\) \u662f\u5947\u6570\u65f6\uff0c \\(\\varphi(2n)=\\varphi(n)\\) \\(n > 2\\) \u65f6\uff0c \\(\\varphi(n)\\) \u4e3a\u5076\u6570 \\(n=\\sum_{d|n}\\varphi(d)\\) \u6b27\u62c9\u5b9a\u7406\uff0c\u82e5 \\(gcd(a,m)=1\\) \uff0c\u5219 \\(a^{\\varphi(m)}\\equiv 1(mod \\quad m)\\) \u6269\u5c55\u6b27\u62c9\u5b9a\u7406 $$ a^b\\equiv \\begin{cases} a^{b \\% \\varphi(p)},\\quad\\quad\\quad gcd(a,p)=1 \\ a^b,\\quad \\quad \\quad \\quad \\quad gcd(a,p)\\neq1,b<\\varphi(p) \\quad\\quad (mod\\quad p) \\ a^{b \\% \\varphi(p)+\\varphi(p)},\\quad gcd(a,p)\\neq1,b\\geq\\varphi(p) \\end{cases} $$","title":"1.3.1 \u57fa\u672c\u6027\u8d28"},{"location":"OI/%E6%95%B0%E8%AE%BA/#132","text":"\\[O(\\sqrt{n})\\] ll phi(ll n){ ll res = n; for(ll i = 2; i*i <= n; i++){ if(n%i==0){ res -= res/i; while(n%i==0) n/=i; } } if(n > 1) res -= res/n; return res; }","title":"1.3.2 \u6c42\u5355\u4e2a\u6570\u7684\u6b27\u62c9\u51fd\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#133","text":"\\(\\varphi(x)=x\\prod_{i=1}^n{(1-\\frac{1}{p_i})}\\) void euler(int n){ for (int i=1; i<=n; i++) phi[i] = i; for (int i=2; i<=n; i++) if (phi[i] == i)//\u8fd9\u4ee3\u8868i\u662f\u8d28\u6570 for (int j=i; j<=n; j += i) phi[j] = phi[j]/i*(i-1);//\u628ai\u7684\u500d\u6570\u66f4\u65b0\u6389 }","title":"1.3.3\u57c3\u6c0f\u6c42\u6b27\u62c9\u51fd\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#134","text":"\\(if(i\\%prime[j] != 0)\\) \uff0c\u5219 \\(i\\) \u4e0e \\(prime[j]\\) \u4e92\u8d28 \u7531\u79ef\u6027\u6027\u8d28\u53ef\u5f97\uff0c \\(phi[i*prime[j]] = phi[i]*phi[prime[j]]\\) \\(if(i\\%prime[j] == 0)\\) \uff0c\u5219 i \u4e2d\u6709 i*prime[j] \u7684\u6240\u6709\u8d28\u56e0\u5b50\uff0c\u6709 \\(\\varphi(i*prime[j])=prime[j]*i*\\prod_{k=1}^n{(1-\\frac{1}{k_i})}=\\varphi(i)*prime[j]\\) int prime[maxn], cnt = 0; bool vis[maxn]; void euler(int n){ phi[1]=1; //1\u8981\u7279\u5224 for (int i=2; i < =n; i++){ if (vis[i] == 0){ //i\u662f\u8d28\u6570 prime[cnt++] = i; phi[i] = i-1; } for (int j=1; j < cnt && prime[j]*i <= n; j++){ vis[i*prime[j]] = 1; if (i%prime[j] == 0){ phi[i*prime[j]] = phi[i]*prime[j];//\u82e5prime[j]\u662fi\u7684\u8d28\u56e0\u5b50\uff0c\u5219\u6839\u636e\u8ba1\u7b97\u516c\u5f0f\uff0ci\u5df2\u7ecf\u5305\u62eci*prime[j]\u7684\u6240\u6709\u8d28\u56e0\u5b50 break;//\u4fdd\u8bc1\u6bcf\u4e2a\u6570\u53ea\u4f1a\u88ab\u81ea\u5df1\u6700\u5c0f\u7684\u56e0\u5b50\u7b5b\u6389\u4e00\u6b21 } else phi[i*prime[j]] = phi[i]*phi[prime[j]];//\u79ef\u6027\u51fd\u6570\u7684\u6027\u8d28 } } }","title":"1.3.4\u6b27\u62c9\u7b5b\u6c42\u6b27\u62c9\u51fd\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#14","text":"","title":"1.4 \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"OI/%E6%95%B0%E8%AE%BA/#141-crt","text":"\u6d1b\u8c37 P3868 $X \u2261 r_{i} ( mod\\quad m_{i} ) $ \u8981\u6c42\uff1am~i~ \u4e24\u4e24\u4e92\u8d28 ll CRT(ll n, ll *r, ll *m){ ll res = 0, M = 1; for(int i = 0; i < n; i++) M *= m[i]; for(int i = 0; i < n; i++) { ll x, y; ll tmp = M / m[i]; ll d = exgcd(tmp, m[i], x, y); //gcd(tmp, m[i]) = 1 x = (x%m[i]+m[i])%m[i]; res = (res + tmp*x*r[i]) % M; //\u53ef\u80fd\u9700\u8981\u7528\u5230\u5feb\u901f\u4e58\u9632\u6b62\u6ea2\u51fa } return (res + M) % M; }","title":"1.4.1 CRT"},{"location":"OI/%E6%95%B0%E8%AE%BA/#142-excrt","text":"\u6d1b\u8c37 P4777 \\(X \u2261 r_{i} ( mod\\quad m_{i} )\\) \u4e0d\u8981\u6c42 m~i~ \u4e24\u4e24\u4e92\u8d28 \u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u7684\u89e3\u4e3a r~1~ \u5047\u8bbe\u6ee1\u8db3\u524d k-1 \u4e2a\u6761\u4ef6\u7684\u4e00\u4e2a\u7279\u89e3\u4e3a res\uff0c M~k-1~ \u4e3a\u524d k-1 \u4e2a m \u7684 lcm \u5219\u524d k-1 \u4e2a\u65b9\u7a0b\u7684\u901a\u89e3\u4e3a $$ res+x\\times M_{k-1} $$ \u90a3\u4e48\u5bf9\u4e8e\u524d k \u4e2a\u65b9\u7a0b,\u5982\u679c\u6709\u89e3\uff0c\u5219 \u5b58\u5728\u6574\u6570 x\uff0c\u4f7f $$ res+x\\times M_{k-1}\\equiv r_k\\quad (mod\\quad m_k) $$ \u5373 $$ x\\times M_{k-1}\\equiv r_k-res\\quad (mod\\quad m_k) $$ \u5229\u7528\u62d3\u6b27\u6c42\u89e3\u5f97 x\uff0c\u5219\u524d k \u4e2a\u65b9\u7a0b\u7684\u4e00\u4e2a\u7279\u89e3\u4e3a $$ res+x\\times M_{k-1} $$ \u901a\u89e3\u4e3a $ \u7279\u89e3 + x^{'}M_k$ ll EXCRT(ll n, ll *r, ll *m){ ll res = r[0], M = m[0]; ll x, y; for(int i = 1; i < n; i++) { ll c = (r[i] - res%m[i] +m[i]) % m[i]; ll d = exgcd(M, m[i], x, y), bg = m[i]/d; x = (x%bg+bg)%bg; if(c%d != 0) return -1; //\u65e0\u89e3,\u56e0\u4e3a\u65e0\u6cd5\u8ba9\u4f59\u6570\u6269\u5927\u6210c x = mul(x, c/d, bg); //\u5feb\u901f\u4e58 res += x*M; M *= bg; //lcm res = (res%M+M)%M; } return res; }","title":"1.4.2 EXCRT"},{"location":"OI/%E6%95%B0%E8%AE%BA/#15","text":"","title":"1.5 \u540c\u4f59\u95ee\u9898"},{"location":"OI/%E6%95%B0%E8%AE%BA/#151","text":"\u540c\u4f59\u4e0d\u6ee1\u8db3\u9664\u6cd5\uff0c \\(a/b\\quad mod \\quad p\\quad != (a\\quad mod\\quad p)/(b\\quad mod\\quad p)\\) \u5f15\u5165 b \u7684\u9006\u5143 x, \u5373 \\(b*x = 1 (mod\\quad p)\\) \uff0cb \u4e0e p \u4e92\u8d28 \u5047\u8bbe $ a/b = k (mod\\quad p)$ \u540c\u4e58 bx \u5f97 $ a/b * bx = k * 1\uff08mod\\quad p)$ \u200b \\(a*x = k (mod\\quad p)\\) \u6ce8\u610f\uff1a b \u548c p \u4e92\u8d28\uff0cb \u624d\u6709\u5173\u4e8e p \u7684\u9006\u5143","title":"1.5.1 \u9006\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#152","text":"\u8d39\u9a6c\u5c0f\u5b9a\u7406 \uff1a\u5982\u679cp\u4e3a\u8d28\u6570\uff0c\u4e14 a \u4e0e p \u4e92\u8d28(\u5373 a \u4e0d\u662f p \u7684\u500d\u6570)\uff0c\u5219 \\(a^{p-1} \\equiv 1 \uff08mod\\quad p)\\) \u6240\u4ee5\u6709 \\(a * a^{p-2} \\equiv 1 (mod\\quad p)\\) , \u5373 \\(a^{p-2} (mod\\quad p)\\) \u662f a \u7684\u9006\u5143 //\u7528\u5feb\u901f\u5e42 ll pow(ll a, ll p){ int res = 1; int d = p-2; while(d) { if(d&1) res = res*a%p; a = a*a%p; d >>= 1; } return res; }","title":"1.5.2 \u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#153","text":"\u5982\u679cb \u4e0e p \u4e92\u8d28\uff0c\u5373 \\(gcd(b, p) = 1\\) \u8981\u89e3 \\(b*x = 1 (mod\\quad p)\\) , \u5373\u6c42 \\(bx + yp = 1 = gcd(b, p)\\) \u7684\u89e3 x ll inv(ll b, ll p) { ll x, y; ll d = exgcd(b, p, x, y); return d == 1 ? (x+p)%p : -1; //\u8fd4\u56de -1 \u8bf4\u660e b,p \u4e0d\u4e92\u8d28 }","title":"1.5.3 \u62d3\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u9006\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#154","text":"\u6d1b\u8c37 P3811 \u662f\u8d39\u5c0f\u7684\u63a8\u5e7f\uff0c\u4e0d\u8981\u6c42 p \u4e3a\u8d28\u6570\uff0c\u4f46 \\( \\(gcd(a,p)=1\\) \\) \\[a^{\\varphi(p)}\\equiv1(mod\\quad p)$$\uff0c\u6240\u4ee5\u5176\u9006\u5143\u4e3a $$a^{\\varphi(n)-1}\\] ll phi(ll n){ ll res = n; for(ll i = 2; i*i <= n; i++) { if(n%i==0) { res -= res/i; while(n%i==0) n/=i; } } if(n > 1) res -= res/n; return res; } ans = pow(a, phi(p)-1,p);","title":"1.5.4 \u6b27\u62c9\u51fd\u6570\u6c42\u9006\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#155","text":"\u6c42\u9636\u4e58\u7684\u9006\u5143\uff0c\u5148\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u51fa n! \u5728 p \u4e0b\u7684\u9006\u5143\uff0c\u518d\u5f80\u524d\u63a8 \u5047\u8bbe n! \u7684\u9006\u5143\u4e3a [n!]^-1^, \u8981\u6c42 (n-1)! \u7684\u9006\u5143 $$ (n-1)! \\times n[n!]^{-1} \u2261 1 (mod\\quad p) $$ \u6240\u4ee5\uff0c(n-1)! \u7684\u9006\u5143\u5c31\u662f n[n!] -1 void fa_inv(ll n, ll p){ fact[0] = 1; //factorial for(int i = 1; i <= n; i++) fact[i] = fact[i-1]*i % p; finv[N] = pow(fact[n], p-2, p); for(int i = n-1; i >= 0; i--) finv[i] = (i+1)*finv[i+1]%p; }","title":"1.5.5 \u9636\u4e58\u9006\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#156","text":"\u6d1b\u8c37 P3811 \u8981\u6c42\u51fa 1-n \u4e2d\u6240\u6709\u6570\u5bf9 p \u7684\u9006\u5143\uff0c\u9009\u62e9\u6253\u8868 \u200b \\(1^{\u22121} \u2261 1 (mod\\quad p)\\) \u8bbe \\(p = k * i + r\\) \u5176\u4e2d 1 < r < i < p, \u5373 \\(k = p/i, r = p\\quad mod\\quad i\\) \u6240\u4ee5\u6709 \\(k * i + r \u2261 0 ( mod\\quad p )\\) \u4e24\u8fb9\u540c\u65f6\u4e58\u4e0a \\(i^{\u22121} * r^{\u22121}\\) \u5f97 $k * r^{\u22121} + i^{\u22121} \u2261 0 ( mod\\quad p ) $ \u200b \\(i^{\u22121} \u2261 \u2212k * r^{\u22121} ( mod\\quad p )\\) \u5f97\u9012\u63a8\u516c\u5f0f \\(i^{-1} \u2261 -\uff08p/i) * (p\\quad mod\\quad i)^{-1} (mod\\quad p)\\) \u6574\u7406\u5f97 \\(inv[i] = (p - p/i) * inv[p\\%i] \\% p\\) \u5176\u4e2d p % i \u6bd4 i \u5c0f void inverse=-(int n, int p) { inv[1] = 1; for(int i = 2; i <= n; i++) inv[i] = (ll)(p - p/i) * inv[p%i] % p; }","title":"1.5.6 \u7ebf\u6027\u6c42\u9006\u5143(\u6253\u8868)"},{"location":"OI/%E6%95%B0%E8%AE%BA/#157-lucas","text":"\u6d1b\u8c37 P3807 HDU 3037 \u89e3\u51b3\u7ec4\u5408\u6570\u53d6\u4f59\u7684\u95ee\u9898\uff1a (p\u5fc5\u987b\u662f\u7d20\u6570,\u4e0d\u7136\u4e0d\u80fd\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143) $$ C(n,m) = \\prod_{i=0}^{k}{C(n_i, m_i)}(mod\\quad p) $$ \\[ n = n_k p^k+n_{k-1} p^{k-1}+\\cdots+n_1p+n_0 \\] \\[ m=m_k p^k+m_{k-1} p^{k-1}+\\cdots+m_1p+m_0 \\] //\u9884\u5904\u7406\u9636\u4e58 void getFact(ll p) { fact[0] = 1; for(ll i = 1; i <= p; i++) f[i] = f[i-1]*i%p; } //\u8ba1\u7b97\u7ec4\u5408\u6570 ll comb(ll n, ll m, ll p) { if(m>n) return 0; return fact[n]*pow(f[m],p-2, p)%p*pow(f[n-m], p-2, p)%p; //\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143 } ll lucas(ll n, ll m, ll p) { if(!m) return 1; return lucas(n/p, m/p, p)%p*comb(n%p, m%p, p)%p; }","title":"1.5.7 Lucas\u5b9a\u7406"},{"location":"OI/%E6%95%B0%E8%AE%BA/#158-lucas","text":"\u6d1b\u8c37 P4720 \u89e3\u51b3 p \u662f\u975e\u7d20\u6570\u65f6\u7684\u7ec4\u5408\u6570\u53d6\u4f59\u95ee\u9898 https://blog.csdn.net/qq_30115697/article/details/88942177 https://www.luogu.com.cn/problem/solution/P4720 typedef long long ll; #define N 100 ll n, m, p; ll exgcd(ll a, ll b, ll &x, ll &y) //\u62d3\u6b27 { if(!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a%b, x, y); ll t = x; x = y; y = t-a/b*y; return d; } ll pow(ll a, ll b, ll p) //\u5feb\u901f\u5e42 { ll res = 1; while(b) { if(b&1) res = (res*a)%p; a = (a*a)%p; b >>= 1; } return res; } ll fact(ll n, ll pi, ll pk) //pk = pi^a \u6c42\u9636\u4e58\uff0c\u7ed3\u679c\u662fn!\u53bb\u6389\u6240\u6709 pi \u56e0\u5b50 { if(!n) return 1; //0! = 0 ll res = 1; for(ll i = 2; i <= pk; i++) //\u5904\u7406\u5faa\u73af\u8282\u5185\u7684\u6570\u5b57 if(i%pi) res = (res*i)%pk; res = pow(res, n/pk, pk); //\u6240\u6709\u5faa\u73af\u8282\u7684\u4e58\u79ef for(ll i = 2; i <= n%pk; i++) //\u5355\u72ec\u9879 if(i%pi) res = (res*i)%pk; return ans*fac(n/pi, pi, pk)%pk; } inline ll inv(ll n, ll mod) { ll x, y; exgcd(n, mod, x, y); return (x%mod+mod)%mod; } inline crt(ll b, ll mod) { return b*inv(p/mod, mod)%p*(p/mod)%p; //\u4f59\u6570\u4e3a 1 } inline ll comb(ll n, ll m, ll pi, ll pk) { ll up = fact(n, pi, pk); ll d1 = fact(m, pi, pk); ll d2 = fact(n-m, pi, pk); ll cnt = 0; for(ll i = p; i <= n; i *= pi) cnt += n/i; for(ll i = p; i <= m; i *= pi) cnt -= m/i; for(ll i = p; i <= n-m; i *= pi) cnt -= (n-m)/i; return up*inv(d1, pk)%pk*inv(d2, pk)%pk*pow(pi, cnt, pk)%pk; } ll exLucas(ll n, ll m) { ll res = 0, tmp = p, pk; for(ll i = 2; i*i <= p; i++) if(tmp % i == 0) { pk = 1; while(tmp%i==0) } } int main() { cin >> n >> m >> p; cout << exLucas(n, m); return 0; }","title":"1.5.8 *\u62d3\u5c55Lucas"},{"location":"OI/%E6%95%B0%E8%AE%BA/#159-bsgs","text":"\u6c42 \\(a^x=b(mod\\ \\ p)\\) \u7684 x \u6700\u5c0f\u7684\u89e3 ll bsgs(ll a, ll b, ll p) { map<ll, ll> hash; hash.clear(); b %= p; ll t = sqrt(p) + 1; for (ll i = 0; i < t; i++) hash[b * ksm(a, i, p) % p] = i; a = ksm(a, t, p); if (!a) return b == 0 ? 1 : -1; for (ll i = 1; i <= t; i++) { ll val = ksm(a, i, p); int j = hash.find(val) == hash.end() ? -1 : hash[val]; if (j >= 0 && i * t - j >= 0) return i * t - j; } return -1; //\u65e0\u89e3 }","title":"1.5.9 BSGS"},{"location":"OI/%E6%95%B0%E8%AE%BA/#18","text":"","title":"1.8 \u6570\u503c\u5206\u6790"},{"location":"OI/%E6%95%B0%E8%AE%BA/#181-simpson","text":"\u5982\u679c\u539f\u51fd\u6570\u662f\u6b21\u6570\u4e0d\u8d85\u8fc7\u4e8c\u6b21\u7684\u591a\u9879\u5f0f\uff0c\u53ef\u4ee5\u7cbe\u786e\u8ba1\u7b97\u79ef\u5206\u503c\uff0c\u53ea\u9700\u8981\u77e5\u9053\u7aef\u70b9\u548c\u4e2d\u70b9\u7684\u503c $$ \\int_{a}^{b}{f(x)}dx \\approx \\frac{b-a}{6}(\\quad f(a)+4f(\\frac{a+b}{2})+f(b)\\quad) $$","title":"1.8.1 Simpson \u516c\u5f0f"},{"location":"OI/%E6%95%B0%E8%AE%BA/#182","text":"\u6d1b\u8c37 P3389 \\( \\(O(n^3)\\) \\) \uff0c\u65b9\u7a0b\u6570\u548c\u672a\u77e5\u6570\u90fd\u8981\u6c42\u662fn\uff0c\u7ed3\u679c\u5728 a [i] [n+1]\u4e2d\uff0c\u8fd4\u56de\u503c1\u8868\u793a\u6709\u552f\u4e00\u89e3\uff0c0\u8868\u793a\u65e0\u89e3 const double eps = 1e-8; int guass_jordan(int n) { for(int i = 1; i <= n; i++) { int r = i; for(int j = i; j <= n; j++)//\u628a\u6b63\u5728\u5904\u7406\u7684\u672a\u77e5\u6570\u7cfb\u6570\u7edd\u5bf9\u503c\u6700\u5927\u7684\u653e\u4e0a\u6765 if(fabs(a[r][i]) < fabs(a[j][i])) r = j; if(r != i) //\u4ea4\u6362 for(int j = 1; j <= n+1; j++) swap(a[i][j], a[r][j]); if(fabs(a[i][i]) < eps) return 0; //\u65e0\u89e3 for(int j = i+1; j <= n+1; j++) a[i][j] /= a[i][i]; //\u7cfb\u6570\u5316\u4e3a1,\u6ce8\u610fi+1\uff0c\u5982\u679c\u4ecei\u5f00\u59cb\u4f1a\u5f71\u54cd\u5230\u540e\u9762 for(int j = 1; j <= n; j++) if(j != i) for(int k = i+1; k <= n+1; k++) //\u6ce8\u610fi+1\uff0c\u5982\u679c\u4ecei\u5f00\u59cb\u4f1a\u5f71\u54cd\u5230\u540e\u9762 a[j][k] -= a[i][k]*a[j][i]; } return 1; }","title":"1.8.2 \u9ad8\u65af\u7ea6\u65e6\u6d88\u5143"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_1","text":"","title":"\u5176\u4ed6"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_2","text":"\u82e5 a,b \u662f\u6574\u6570,\u4e14 \\(gcd(a,b)=d\\) \uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u7684\u6574\u6570 x,y, \\(ax+by\\) \u90fd\u4e00\u5b9a\u662f d \u7684\u500d\u6570\uff0c\u5373 \\( \\(d|(ax+by)\\) \\) \u7279\u522b\u5730\uff0c\u4e00\u5b9a\u5b58\u5728\u6574\u6570x,y\uff0c\u4f7fax+by=d\u6210\u7acb\u3002 \u91cd\u8981\u63a8\u8bba\uff1aa,b\u4e92\u8d28\u7684\u5145\u8981\u6761\u4ef6\u662f\u5b58\u5728\u6574\u6570 x,y \u4f7f ax+by=1.","title":"\u88f4\u8700\u5b9a\u7406"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_3","text":"\u6b63\u6574\u6570 \\(N\\) \u7684\u6807\u51c6\u5206\u89e3\u5f0f\uff1a \\(N=p_1^{a_1}p_2^{a_2}...p_n^{a_n}\\) \u90a3 \\(N\\) \u7684\u6b63\u56e0\u6570\u4e2a\u6570\u4e3a \\(\\sigma_0(N)=(1+a_1)(1+a_2)...(1+a_n)\\) \u6240\u6709\u6b63\u56e0\u6570\u7684\u548c\u4e3a \\(\\sigma_1(N)=(1+p_1+p_1^2+...+p_1^{a_1})...(1+p_n+p_n^2+...+p_n^{a_n})\\)","title":"\u552f\u4e00\u5206\u89e3\u5b9a\u7406"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_4","text":"\\(\\frac{n}{1}+\\frac{n}{2}+\\frac{n}{3}+..+\\frac{n}{n}\\) \u7684\u548c ll ans = 0; for (int l = 1, r; l <= n; l = r + 1) { r = n / (n / l); //\u6bcf\u6bb5\u533a\u95f4\u7684\u53f3\u7aef\u70b9 ans += (ll)(n / l) * (r - l + 1); }","title":"\u6574\u6570\u5206\u5757"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_5","text":"\\[ n! \\approx \\sqrt{2 \\pi n}(\\frac{n}{e})^n \\] \u7528 log10 \u5feb\u901f\u8ba1\u7b97\u5927\u6570\u7684\u4f4d\u6570","title":"\u65af\u7279\u6797\u516c\u5f0f"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_6","text":"\\[ f(n) = (n-1)(f(n-1)f(n-2)) \\]","title":"\u9519\u6392\u516c\u5f0f"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_7","text":"HDU 4135 $$ |U(A_i)|=\\sum_{1\\leq i\\leq m}{|A_i|}-\\sum_{i\\leq i<j\\leq m}{|A_i\\bigcap A_j|}+ \\dots+(-1)^{m+1}\\sum|A_1\\bigcap A_2\\bigcap \\dots\\bigcap A_m| $$ void solve() { int res = 0; for(int i = 1; i < (1<<m); i++) { int cnt = 0; for(int j = i; j != 0; j >>= 1) cnt += j&1; ll lcm = 1; for(int j = 0; j < m; j++) { if( (i>>j) & 1) { lcm = lcm / gcd(lcm, num[j]) * num[j]; //eg,\u662f2\u7684\u500d\u6570\u4e0d\u4e00\u5b9a\u662f4\u7684\u500d\u6570 if(lcm > n) break; } } if(cnt % 2 == 0) res -= n/lcm; else res += n/lcm; } cout << res; }","title":"\u5bb9\u65a5\u539f\u7406"},{"location":"OI/%E6%95%B0%E8%AE%BA/#catalan","text":"\u8bbe h(n) \u8868\u793a Catalan\u6570\u7684\u7b2cn\u9879\uff0ch(0) = 1, h(1) = 1 \u9012\u63a8\u5f0f\uff1a \\(h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)(n\\geq2)\\) \u53e6\u7c7b\u9012\u63a8\u5f0f\uff1a \\(h(n)=h(n-1)*(4*n-2)/(n+1)\\) \u9012\u63a8\u5173\u7cfb\u7684\u89e3\uff1a \\(h(n)=C(2n,n)/(n+1)(n=0,1,2,...)\\) \u9012\u63a8\u5173\u7cfb\u7684\u53e6\u7c7b\u89e3\uff1a \\(h(n)=C(2n,n)-C(2n,n-1)(n=0,1,2,...)\\) eg\uff1a\u8fdb\u51fa\u6808\uff0c\u7535\u5f71\u8d2d\u7968\uff0c\u5706\u5185\u8fde\u5f26\uff0c\u51f8\u591a\u8fb9\u5f62\u7684\u5256\u5206\uff0cn\u5bf9\u62ec\u53f7\u5f62\u6210\u7684\u5408\u6cd5\u62ec\u53f7\u8868\u8fbe\u5f0f\u7684\u4e2a\u6570\uff0c n+1\u4e2a\u6570\u8fde\u4e58\u4e0d\u540c\u7684\u4e58\u6cd5\u987a\u5e8f\u6570\u3001","title":"Catalan\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#bellstirling","text":"\u7b2c\u4e00\u7c7b Stirling\u6570\u9012\u63a8\u5f0f\uff1a \\(S(i,j)=(i-1)*S(i-1,j)+S(i-1,j-1)\\) eg\uff1ai \u4e2a\u4e0d\u540c\u5143\u7d20\u6784\u6210 j \u4e2a\u5706\u6392\u5217\u7684\u6570\u76ee \u7b2c\u4e8c\u7c7b Stirling\u6570\u9012\u63a8\u5f0f\uff1a \\(S(i,j)=j*S(i-1,j)+S(i-1,j-1)\\) eg\uff1ai \u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u5212\u5206\u4e3a j \u4e2a\u975e\u7a7a\u96c6\u7684\u65b9\u6cd5\u7684\u6570\u76ee Bell\u6570\u548c\u7b2c\u4e8c\u7c7bStirling\u6570\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a \\(B_n=\\sum_{k=1}^n{S(n,k)}\\) eg\uff1an \u4e2a\u4e0d\u540c\u7684\u6570\u7684\u5212\u5206\u65b9\u6848\u6570","title":"Bell\u6570\u548cStirling\u6570"},{"location":"OI/%E6%95%B0%E8%AE%BA/#_8","text":"\u4e00\u4e2a\u6b27\u62c9\u51fd\u6570\u7684\u6027\u8d28\uff1a $$ m = \\sum_{d|m}{\\varphi(d)} $$ \u76f8\u4f3c\u5f62\u5f0f\u7684\u4e00\u4e2a\u91cd\u8981\u7ed3\u8bba\uff1a $$ g(m)=\\sum_{d|m}{f(d)} $$ \u5176\u4e2d\u5982\u679c f(d) \u8ba9 g(m) \u662f\u79ef\u6027\u51fd\u6570\uff0c\u90a3\u4e48 f(d) \u662f\u79ef\u6027\u51fd\u6570 \u53c8\u56e0\u4e3a m \u662f\u79ef\u6027\u7684\uff0c\u6240\u4ee5\u6b27\u62c9\u51fd\u6570 \\( \\(\\varphi(d)\\) \\) \u4e5f\u662f\u79ef\u6027\u7684\uff08\u6b27\u62c9\u51fd\u6570\u7684\u79ef\u6027\u5fc5\u987b\u4e24\u6570\u4e92\u8d28\uff09 \u6b27\u62c9\u51fd\u6570\u79ef\u6027\u7684\u8bc1\u660e\uff08\u4e24\u6570\u4e92\u8d28\uff09\uff1a \u56e0\u4e3a g(m) \u4e3a\u79ef\u6027 \u6269\u5c55\u5de6\u8fb9 \\( \\(g(m_1m_2)=\\sum_{d|m_1m_2}{f(d)}=\\sum_{d_1|m_1}\\sum_{d_2|m_2}f(d_1)f(d_2)\\) \\) \u6269\u5c55\u53f3\u8fb9 \\( \\(g(m_1)g(m_2)=\\sum_{d_1|m_1}f(d_1)\\sum_{d_2|m_2}{f(d_2)}\\) \\) \u200b \u6709 \\( \\(g(m_1m_2)=g(m_1)g(m_2)\\) \\) \u9006\u547d\u9898\u4e5f\u6210\u7acb\uff0c\u6240\u4ee5\u4e24\u6570\u4e92\u8d28\u65f6\u6b27\u62c9\u51fd\u6570\u6709\u79ef\u6027","title":"\u6b27\u62c9\u51fd\u6570\u4e0e\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570*"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","text":"2 \u8ba1\u7b97\u51e0\u4f55 2.1 \u70b9\u548c\u7ebf 2.1.1 \u7cbe\u5ea6\u63a7\u5236 const double eps = 1e-10; double dcmp(double x) { //\u5224\u65ad \u6b63/\u8d1f/0 if(fabs(x) < eps) return 0; else return x > 0 ? 1 : -1; } 2.1.2 \u70b9\u548c\u5411\u91cf\u5b58\u50a8 struct Vector{ double x, y; Point(double x = 0, y = 0):x(x), y(y){} Vector rotate_90() {return Vector(y, -x);} //\u987a\u65f6\u948890\u5ea6 Vector rotate_90_c() {return Vector(-y, x);} //\u9006\u65f6\u948890\u5ea6 }; typedef Vector Point; 2.1.3 \u5411\u91cf\u7684\u56db\u5219\u8fd0\u7b97 //\u8fd9\u79cd\u8fd4\u56de\u65b9\u5f0f\u4f3c\u4e4e\u6709\u65f6\u5019\u4f1a\u51fa\u95ee\u9898 //\u5411\u91cf+\u5411\u91cf=\u5411\u91cf \u70b9+\u5411\u91cf=\u70b9 Vector operator+(Vector a, Vector b){ return Vector(a.x+b.x, a.y+b.y); } //\u70b9-\u70b9=\u5411\u91cf Vector operator-(Vector a, Vector b){ return Vector(a.x-b.x, a.y-b.y); } //\u5411\u91cf*\u6570=\u5411\u91cf Vector operator*(Vector a, double p){ return Vector(a.x*p, a.y*p); } //\u5411\u91cf/\u6570=\u5411\u91cf Vector operator/(Vector a, double p){ return Vector(a.x/p. a.y/p); } 2.1.4 \u70b9\u79ef \u53c9\u79ef \u53ca \u5e94\u7528 \\[\\vec{a} \\cdot \\vec{b} = |a||b|cos\\theta\\] \\( \\(|\\vec{a} \\times \\vec{b}| = |a||b|sin\\theta\\) \\) \uff0c\u6b63\u8d1f\u7531\u4e24\u5411\u91cf\u7684\u76f8\u5bf9\u5173\u7cfb\u51b3\u5b9a //\u70b9\u79ef double Dot(Vector a, Vector b){ return a.x*b.x+a.y*b.y; } //\u53c9\u79ef double Cross(Vector a, Vector b){ return a.x*b.y-a.y*b.x; } //\u5e94\u7528 //\u6c42\u6a21\u957f double Length(Vector a){ return sqrt(Dot(a, a)); } //\u6c42\u89d2\u5ea6 double Angle(Vector a, Vector b){ return acos(Dot(a, b)/Length(a)/Length(b)); } 2.1.5 \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a bool OnSegment(Point p1, Point p2, Point q){ //p1-p2\u662f\u7ebf\u6bb5 return Cross(p1-q, p2-q) == 0 && Dot(p1-q, p2-q) <= 0; } 2.1.6 \u6c42\u4e24\u76f4\u7ebf\u7684\u4ea4\u70b9 \u7531 \\( \\(q_2,q_1,p_2,p_1\\) \\) \u786e\u5b9a\u7684\u4e24\u6761\u76f4\u7ebf\uff0c\u5047\u8bbe\u4ea4\u70b9\u4e3a \\( \\(p_1+t(p_2-p_1)\\) \\) \u6709 \\( \\((q_2-q_1) \\times (p_1 + t(p_2-p_1)-q_1)=0\\) \\) \u5f97 \\( \\(t = \\frac{(q_2-q_1)\\times(q_1-p_1)}{(q_2-q_1)\\times(p_2-p_1)}\\) \\) /*Point GetLineIntersection(Point p1, Point p2, Point q1, Point q2){ return p1+(p2-p1)*Cross(q2-q1, q1-p1)/Cross(q2-q1, p2-p1) }*/ Point GetLineIntersection(Point p, Vector v1, Point q, Vector v2){ return p+v1*Cross(v2, q-p)/Cross(v2, v1); } //\u5e73\u884c\u7279\u5224 2.1.7 \u7ebf\u6bb5\u76f8\u4ea4\u5224\u5b9a \u5224\u65adq1,q2\u5728\u7ebf\u6bb5p2-p1\u4e24\u4fa7 \u4e14 p1,p2\u5728\u7ebf\u6bb5q2-q1\u4e24\u4fa7 bool SegmentProperIntersection(Point p1, Point p2, Point q1, Point q2){ double a1 = Cross(p2-p1, q2-p1), a2 = Cross(p2-p1, q1-p1); double a3 = Cross(q2-q1, p1-q1), a4 = Cross(q2-q1, p2-q1); return dcmp(a1)*dcmp(a2)<0 && dcmp(a3)*dcmp(a4)<0; } /*\u7279\u5224\u7aef\u70b9\u5728\u53e6\u4e00\u6761\u7ebf\u6bb5\u7684\u60c5\u51b5 if(OnSegment(p[i],q[i],p[j]) || OnSegment(p[i],q[i],q[j]) || OnSegment(p[j],q[j],p[i]) || OnSegment(p[j],q[j],q[i]) ) G[i][j] = G[j][i] = true; */ \u7ebf\u6bb5\u548c\u76f4\u7ebf\u76f8\u4ea4\u5224\u5b9a bool fun(Point a, Point b, Point c, Point d) { //a b \u786e\u5b9a\u76f4\u7ebf c d \u786e\u5b9a\u7ebf\u6bb5 return Cross(a - b, a - c) * Cross(a - b, a - d) <= eps } \u5411\u91cf\u65cb\u8f6c\u4e0e\u5355\u4f4d\u5316 \u9006\u65f6\u9488\uff1a $$ \\left[ \\matrix{ x^{'} \\ y^{'} } \\right] = \\left[ \\matrix{ x \\ y } \\right] \\left[ \\matrix{ cos\\theta & sin\\theta\\ -sin\\theta & cos\\theta } \\right] $$ \u987a\u65f6\u9488\uff1a $$ \\left[ \\matrix{ x^{'} \\ y^{'} } \\right] = \\left[ \\matrix{ x \\ y } \\right] \\left[ \\matrix{ cos\\theta & -sin\\theta\\ sin\\theta & cos\\theta } \\right] $$ //rad \u662f\u5f27\u5ea6, \u9006\u65f6\u9488 Vector Rotate(Vector a, double rad) { return Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*soc(rad)); } //\u5355\u4f4d\u5316 Vector Normal(Vector a) { double L = length(a); return Vector(a.x/L, a.y/L); } \u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb double DistaceToLine(Point p, Point a, Point b) { Vector v1 = b-a, v2 = p-a; return fabs(Cross(v1, v2))/Length(v1); //\u5e73\u884c\u56db\u8fb9\u5f62\u9762\u79ef \u9664/\u5e95=\u9ad8 } \u70b9\u5230\u7ebf\u6bb5\u4ea4\u70b9 2.2 \u5706 2.2.1 \u5706\u7684\u5b58\u50a8 struct Circle{ Point c; double r; Circle(Point a, double b = 0):c(a), r(b){} } \u4e09\u89d2\u5f62\u5916\u63a5\u5706 //\u4e09\u70b9\u4e0d\u5171\u7ebf Circle circumcircle(Point p1, Point p2, Point p3) { Point p = GetLineIntersection((p1+p2)/2, (p2-p1).rotate_90(), (p1+p3)/2, (p3-p1).rotate_90()); return Circle(p, Length(p1-p)); } \u6700\u5c0f\u5706\u8986\u76d6 \u968f\u673a\u589e\u91cf\u6cd5 \\(O(n)\\) //\u6d1b\u8c37 P1742 #include<iostream> #include<algorithm> #include<cmath> using namespace std; const int maxn = 1e5+5; typedef struct Vector{ double x, y; Vector(double a = 0, double b = 0):x(a),y(b){} Vector rotate_90(){return Vector(y, -x); } }Point; struct Circle{ Point c; double r; Circle(Point a, double b):c(a),r(b){} }; Point operator-(const Point& a, const Point& b){ return Vector(a.x-b.x, a.y-b.y); } Point operator+(const Point& a, const Point& b){ return Vector(a.x+b.x, a.y+b.y); } Point operator/(const Point& a, const double& b){ return Vector(a.x/b, a.y/b); } Point operator*(const Point& a, const double& b){ return Vector(a.x*b, a.y*b); } double Dot(Vector a, Vector b){ return a.x*b.x+a.y*b.y; } double Cross(Vector a, Vector b){ return a.x*b.y-a.y*b.x; } double Length(Vector a){ return sqrt(Dot(a, a)); } Point GetLineIntersection(Point p, Vector v1, Point q, Vector v2){ return p+v1*Cross(v2, q-p)/Cross(v2, v1); } Circle circumcircle(Point p1, Point p2, Point p3){ Point p = GetLineIntersection((p1+p2)/2, (p2-p1).rotate_90(), (p1+p3)/2, (p3-p1).rotate_90()); return Circle(p, Length(p1-p)); } Circle min_circle(Point *p, int n) { //\u6700\u5c0f\u5706\u8986\u76d6 random_shuffle(p+1, p+1+n); Point o; double r = 0; for(int i = 1; i <= n; i++) if(Length(p[i]-o) > r) { o = p[i], r = 0; for(int j = 1; j < i; j++) if(Length(p[j]-o) > r) { o = (p[i]+p[j])/2, r = Length(p[i]-p[j])/2; for(int k = 1; k < j; k++) if(Length(o-p[k]) > r) { Circle tmp = circumcircle(p[i], p[j], p[k]); o = tmp.c, r = tmp.r; } } } return Circle(o, r); } int main(){ int n; Point p[maxn]; cin >> n; for(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y; Circle res = min_circle(p, n); printf(\"%.10lf\\n%.10lf %.10lf\\n\", res.r, res.c.x, res.c.y); return 0; } 2.3 \u51f8\u5305 2.3.1 Graham\u626b\u63cf\u6cd5 \u7b97\u51f8\u5305 \u6309x\uff0cy\u5750\u6807\u5347\u5e8f\u6392\u5217\uff0c\u786e\u5b9a\u51f8\u5305\u76842\u7684\u9876\u70b9\uff0c\u7136\u540e\u518d\u786e\u5b9a\u4e0a\u4e0b\u4e24\u4e2a\u51f8\u58f3 \u6392\u5e8f \\( \\(O(nlogn)\\) \\) \u5176\u4ed6 \\( \\(O(n)\\) \\) bool cmp(Point &p, Point &q){ if(p.x != p.x) return p.x < q.x; else return p.y < q.y; } vector<Point> ConvexHull(Point *ps, int n){ sort(ps, ps+n, cmp); int k = 0; //\u51f8\u5305\u9876\u70b9\u6570 vector<Point> qs(n*2); //\u4e0b\u51f8\u58f3 for(int i = 0; i < n; i++){ //while\u8981\u6ce8\u610f while(k > 1 && Cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1] <= 0)) k--; qs[k++] = ps[i]; } //\u4e0a\u51f8\u58f3 for(int i = n-2, t = k; i >= 0; i--){ while(k > t && Cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1] <= 0)) k--; qs[k++] = ps[i]; } qs.resize(k-1); return qs; }","title":"\u8ba1\u7b97\u51e0\u4f55"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#2","text":"","title":"2 \u8ba1\u7b97\u51e0\u4f55"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#21","text":"","title":"2.1 \u70b9\u548c\u7ebf"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#211","text":"const double eps = 1e-10; double dcmp(double x) { //\u5224\u65ad \u6b63/\u8d1f/0 if(fabs(x) < eps) return 0; else return x > 0 ? 1 : -1; }","title":"2.1.1 \u7cbe\u5ea6\u63a7\u5236"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#212","text":"struct Vector{ double x, y; Point(double x = 0, y = 0):x(x), y(y){} Vector rotate_90() {return Vector(y, -x);} //\u987a\u65f6\u948890\u5ea6 Vector rotate_90_c() {return Vector(-y, x);} //\u9006\u65f6\u948890\u5ea6 }; typedef Vector Point;","title":"2.1.2 \u70b9\u548c\u5411\u91cf\u5b58\u50a8"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#213","text":"//\u8fd9\u79cd\u8fd4\u56de\u65b9\u5f0f\u4f3c\u4e4e\u6709\u65f6\u5019\u4f1a\u51fa\u95ee\u9898 //\u5411\u91cf+\u5411\u91cf=\u5411\u91cf \u70b9+\u5411\u91cf=\u70b9 Vector operator+(Vector a, Vector b){ return Vector(a.x+b.x, a.y+b.y); } //\u70b9-\u70b9=\u5411\u91cf Vector operator-(Vector a, Vector b){ return Vector(a.x-b.x, a.y-b.y); } //\u5411\u91cf*\u6570=\u5411\u91cf Vector operator*(Vector a, double p){ return Vector(a.x*p, a.y*p); } //\u5411\u91cf/\u6570=\u5411\u91cf Vector operator/(Vector a, double p){ return Vector(a.x/p. a.y/p); }","title":"2.1.3 \u5411\u91cf\u7684\u56db\u5219\u8fd0\u7b97"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#214","text":"\\[\\vec{a} \\cdot \\vec{b} = |a||b|cos\\theta\\] \\( \\(|\\vec{a} \\times \\vec{b}| = |a||b|sin\\theta\\) \\) \uff0c\u6b63\u8d1f\u7531\u4e24\u5411\u91cf\u7684\u76f8\u5bf9\u5173\u7cfb\u51b3\u5b9a //\u70b9\u79ef double Dot(Vector a, Vector b){ return a.x*b.x+a.y*b.y; } //\u53c9\u79ef double Cross(Vector a, Vector b){ return a.x*b.y-a.y*b.x; } //\u5e94\u7528 //\u6c42\u6a21\u957f double Length(Vector a){ return sqrt(Dot(a, a)); } //\u6c42\u89d2\u5ea6 double Angle(Vector a, Vector b){ return acos(Dot(a, b)/Length(a)/Length(b)); }","title":"2.1.4 \u70b9\u79ef \u53c9\u79ef \u53ca \u5e94\u7528"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#215","text":"bool OnSegment(Point p1, Point p2, Point q){ //p1-p2\u662f\u7ebf\u6bb5 return Cross(p1-q, p2-q) == 0 && Dot(p1-q, p2-q) <= 0; }","title":"2.1.5 \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#216","text":"\u7531 \\( \\(q_2,q_1,p_2,p_1\\) \\) \u786e\u5b9a\u7684\u4e24\u6761\u76f4\u7ebf\uff0c\u5047\u8bbe\u4ea4\u70b9\u4e3a \\( \\(p_1+t(p_2-p_1)\\) \\) \u6709 \\( \\((q_2-q_1) \\times (p_1 + t(p_2-p_1)-q_1)=0\\) \\) \u5f97 \\( \\(t = \\frac{(q_2-q_1)\\times(q_1-p_1)}{(q_2-q_1)\\times(p_2-p_1)}\\) \\) /*Point GetLineIntersection(Point p1, Point p2, Point q1, Point q2){ return p1+(p2-p1)*Cross(q2-q1, q1-p1)/Cross(q2-q1, p2-p1) }*/ Point GetLineIntersection(Point p, Vector v1, Point q, Vector v2){ return p+v1*Cross(v2, q-p)/Cross(v2, v1); } //\u5e73\u884c\u7279\u5224","title":"2.1.6 \u6c42\u4e24\u76f4\u7ebf\u7684\u4ea4\u70b9"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#217","text":"\u5224\u65adq1,q2\u5728\u7ebf\u6bb5p2-p1\u4e24\u4fa7 \u4e14 p1,p2\u5728\u7ebf\u6bb5q2-q1\u4e24\u4fa7 bool SegmentProperIntersection(Point p1, Point p2, Point q1, Point q2){ double a1 = Cross(p2-p1, q2-p1), a2 = Cross(p2-p1, q1-p1); double a3 = Cross(q2-q1, p1-q1), a4 = Cross(q2-q1, p2-q1); return dcmp(a1)*dcmp(a2)<0 && dcmp(a3)*dcmp(a4)<0; } /*\u7279\u5224\u7aef\u70b9\u5728\u53e6\u4e00\u6761\u7ebf\u6bb5\u7684\u60c5\u51b5 if(OnSegment(p[i],q[i],p[j]) || OnSegment(p[i],q[i],q[j]) || OnSegment(p[j],q[j],p[i]) || OnSegment(p[j],q[j],q[i]) ) G[i][j] = G[j][i] = true; */","title":"2.1.7 \u7ebf\u6bb5\u76f8\u4ea4\u5224\u5b9a"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_1","text":"bool fun(Point a, Point b, Point c, Point d) { //a b \u786e\u5b9a\u76f4\u7ebf c d \u786e\u5b9a\u7ebf\u6bb5 return Cross(a - b, a - c) * Cross(a - b, a - d) <= eps }","title":"\u7ebf\u6bb5\u548c\u76f4\u7ebf\u76f8\u4ea4\u5224\u5b9a"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_2","text":"\u9006\u65f6\u9488\uff1a $$ \\left[ \\matrix{ x^{'} \\ y^{'} } \\right] = \\left[ \\matrix{ x \\ y } \\right] \\left[ \\matrix{ cos\\theta & sin\\theta\\ -sin\\theta & cos\\theta } \\right] $$ \u987a\u65f6\u9488\uff1a $$ \\left[ \\matrix{ x^{'} \\ y^{'} } \\right] = \\left[ \\matrix{ x \\ y } \\right] \\left[ \\matrix{ cos\\theta & -sin\\theta\\ sin\\theta & cos\\theta } \\right] $$ //rad \u662f\u5f27\u5ea6, \u9006\u65f6\u9488 Vector Rotate(Vector a, double rad) { return Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*soc(rad)); } //\u5355\u4f4d\u5316 Vector Normal(Vector a) { double L = length(a); return Vector(a.x/L, a.y/L); }","title":"\u5411\u91cf\u65cb\u8f6c\u4e0e\u5355\u4f4d\u5316"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_3","text":"double DistaceToLine(Point p, Point a, Point b) { Vector v1 = b-a, v2 = p-a; return fabs(Cross(v1, v2))/Length(v1); //\u5e73\u884c\u56db\u8fb9\u5f62\u9762\u79ef \u9664/\u5e95=\u9ad8 }","title":"\u70b9\u5230\u76f4\u7ebf\u7684\u8ddd\u79bb"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_4","text":"","title":"\u70b9\u5230\u7ebf\u6bb5\u4ea4\u70b9"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#22","text":"","title":"2.2 \u5706"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#221","text":"struct Circle{ Point c; double r; Circle(Point a, double b = 0):c(a), r(b){} }","title":"2.2.1 \u5706\u7684\u5b58\u50a8"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_5","text":"//\u4e09\u70b9\u4e0d\u5171\u7ebf Circle circumcircle(Point p1, Point p2, Point p3) { Point p = GetLineIntersection((p1+p2)/2, (p2-p1).rotate_90(), (p1+p3)/2, (p3-p1).rotate_90()); return Circle(p, Length(p1-p)); }","title":"\u4e09\u89d2\u5f62\u5916\u63a5\u5706"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#_6","text":"\u968f\u673a\u589e\u91cf\u6cd5 \\(O(n)\\) //\u6d1b\u8c37 P1742 #include<iostream> #include<algorithm> #include<cmath> using namespace std; const int maxn = 1e5+5; typedef struct Vector{ double x, y; Vector(double a = 0, double b = 0):x(a),y(b){} Vector rotate_90(){return Vector(y, -x); } }Point; struct Circle{ Point c; double r; Circle(Point a, double b):c(a),r(b){} }; Point operator-(const Point& a, const Point& b){ return Vector(a.x-b.x, a.y-b.y); } Point operator+(const Point& a, const Point& b){ return Vector(a.x+b.x, a.y+b.y); } Point operator/(const Point& a, const double& b){ return Vector(a.x/b, a.y/b); } Point operator*(const Point& a, const double& b){ return Vector(a.x*b, a.y*b); } double Dot(Vector a, Vector b){ return a.x*b.x+a.y*b.y; } double Cross(Vector a, Vector b){ return a.x*b.y-a.y*b.x; } double Length(Vector a){ return sqrt(Dot(a, a)); } Point GetLineIntersection(Point p, Vector v1, Point q, Vector v2){ return p+v1*Cross(v2, q-p)/Cross(v2, v1); } Circle circumcircle(Point p1, Point p2, Point p3){ Point p = GetLineIntersection((p1+p2)/2, (p2-p1).rotate_90(), (p1+p3)/2, (p3-p1).rotate_90()); return Circle(p, Length(p1-p)); } Circle min_circle(Point *p, int n) { //\u6700\u5c0f\u5706\u8986\u76d6 random_shuffle(p+1, p+1+n); Point o; double r = 0; for(int i = 1; i <= n; i++) if(Length(p[i]-o) > r) { o = p[i], r = 0; for(int j = 1; j < i; j++) if(Length(p[j]-o) > r) { o = (p[i]+p[j])/2, r = Length(p[i]-p[j])/2; for(int k = 1; k < j; k++) if(Length(o-p[k]) > r) { Circle tmp = circumcircle(p[i], p[j], p[k]); o = tmp.c, r = tmp.r; } } } return Circle(o, r); } int main(){ int n; Point p[maxn]; cin >> n; for(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y; Circle res = min_circle(p, n); printf(\"%.10lf\\n%.10lf %.10lf\\n\", res.r, res.c.x, res.c.y); return 0; }","title":"\u6700\u5c0f\u5706\u8986\u76d6"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#23","text":"","title":"2.3 \u51f8\u5305"},{"location":"OI/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#231-graham","text":"\u6309x\uff0cy\u5750\u6807\u5347\u5e8f\u6392\u5217\uff0c\u786e\u5b9a\u51f8\u5305\u76842\u7684\u9876\u70b9\uff0c\u7136\u540e\u518d\u786e\u5b9a\u4e0a\u4e0b\u4e24\u4e2a\u51f8\u58f3 \u6392\u5e8f \\( \\(O(nlogn)\\) \\) \u5176\u4ed6 \\( \\(O(n)\\) \\) bool cmp(Point &p, Point &q){ if(p.x != p.x) return p.x < q.x; else return p.y < q.y; } vector<Point> ConvexHull(Point *ps, int n){ sort(ps, ps+n, cmp); int k = 0; //\u51f8\u5305\u9876\u70b9\u6570 vector<Point> qs(n*2); //\u4e0b\u51f8\u58f3 for(int i = 0; i < n; i++){ //while\u8981\u6ce8\u610f while(k > 1 && Cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1] <= 0)) k--; qs[k++] = ps[i]; } //\u4e0a\u51f8\u58f3 for(int i = n-2, t = k; i >= 0; i--){ while(k > t && Cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1] <= 0)) k--; qs[k++] = ps[i]; } qs.resize(k-1); return qs; }","title":"2.3.1 Graham\u626b\u63cf\u6cd5 \u7b97\u51f8\u5305"}]}